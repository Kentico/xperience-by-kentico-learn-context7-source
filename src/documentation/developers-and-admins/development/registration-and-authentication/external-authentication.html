<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>External authentication</title>
</head>
<body>
<p>External authentication allows visitors to sign in to an application or website using their existing social media credentials, such as Facebook, Twitter, or Google. This eliminates the need for users to create a separate account for the application or website they want to use and simplifies signing in.</p>
<p>To implement social provider authentication, the application or website must integrate with the social platforms’ authentication APIs, which allow users to grant permission for the application to access their account information. Once a user grants permission, the application receives an access token that it uses to authenticate the user for future sessions (typically a cookie).</p>
<p>There are several benefits to implementing authentication using social providers.</p>
<ul>
<li>It simplifies the process for users, as they can use their existing social media credentials to access the application or website.</li>
<li>It can help increase the number of users who sign up for the application or website.</li>
<li>It can improve the security of the application or website, as social media platforms typically have more robust security measures than individual websites or applications.</li>
</ul>
<p>Xperience by Kentico uses <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/identity" target="_blank">ASP.NET Identity</a> to manage user accounts. When implementing this authentication method for Xperience projects, you can choose from the providers supported by Identity, such as Facebook, Twitter, Google, and other OAuth/OIDC-compliant platforms. See the <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social" target="_blank">Identity documentation</a> for details.</p>
<h2 id="prerequisites">Prerequisites</h2>
<p>Before implementing external authentication, you must <a href="/documentation/developers-and-admins/development/registration-and-authentication">enable and configure ASP.NET Identity</a> in your web application.</p>
<h2 id="configure-provider-integration">Configure provider integration</h2>
<p>To configure social provider authentication for your application:</p>
<ol type="1">
<li>Create and configure an application for your Xperience project on the side of the external provider.
<ul>
<li>Save the <em>application ID</em> and <em>application secret</em> values.</li>
<li>See <a href="#general-security-considerations">General security considerations</a> for a list of security practices to keep in mind when configuring the application.</li>
</ul>
</li>
<li>Install the <strong>Microsoft.AspNet.Authentication.*</strong> NuGet package for the provider you want to support.</li>
<li>Call the corresponding extension methods when configuring authentication for the application in <strong>Program.cs</strong>.</li>
<li>Configure the integration.</li>
</ol>
<p>The following code sample configures <a href="https://learn.microsoft.com/en-us/aspnet/core/security/authentication/social/google-logins" target="_blank">Google authentication</a> using the <strong>Microsoft.AspNet.Authentication.Google</strong> package.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Program.cs - ASP.NET Identity configuration</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

builder.Services.AddIdentity&lt;ApplicationUser, NoOpApplicationRole&gt;(options =&gt;
    {
        options.SignIn.RequireConfirmedAccount = true;
    })
        .AddUserStore&lt;ApplicationUserStore&lt;ApplicationUser&gt;&gt;()
        .AddRoleStore&lt;NoOpApplicationRoleStore&gt;()
        .AddUserManager&lt;UserManager&lt;ApplicationUser&gt;&gt;()
        .AddSignInManager&lt;SignInManager&lt;ApplicationUser&gt;&gt;();

// Adds and configures Google authentication
builder.Services.AddAuthentication()
       .AddGoogle(googleOptions =&gt;
            {
                googleOptions.ClientId = "&lt;Google_App_ID&gt;";
                googleOptions.ClientSecret = "&lt;Google_App_Secret&gt;";
            });

</code></pre>
</div>


<div>

</div>
<div>
<p><strong>Storing application secrets</strong></p>
<p>We do not recommend storing application secrets (<code>ClientSecret</code> property) directly in code or application configuration files (e.g., <em>appsettings.json</em>). See <a href="#securely-store-application-secrets">Securely store application secrets</a> for recommendations.</p>
</div>

<h2 id="implement-the-authentication-flow">Implement the authentication flow</h2>
<p>The implementation of an authentication flow can vary depending on the application’s specific requirements. This section introduces a basic flow that you can further extend.</p>
<p>Render buttons that invoke the authentication flow for a corresponding provider in a suitable location in your application.</p>

<div>
<div>
<div>
<span>cshtml</span>
</div>
<strong>SignIn.cshtml</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

@inject SignInManager&lt;ApplicationUser&gt; SignInManager

var signInProviders = (await SignInManager.GetExternalAuthenticationSchemesAsync());
if (signInProviders.Any())
{
    @* Generates a form with buttons targeting the RequestExternalSignIn action.*@
    &lt;form asp-action="RequestExternalSignIn" method="post"&gt;
        &lt;div&gt;
            @foreach (AuthenticationScheme provider in signInProviders)
            {
                &lt;button type="submit" name="provider" value="@provider.Name"&gt;@provider.Name&lt;/button&gt;
            }
        &lt;/div&gt;
    &lt;/form&gt;
}

</code></pre>
</div>

<p>Selecting one of the rendered buttons triggers the following flow:</p>
<ol type="1">
<li><p>The application contacts an external provider that prompts visitors to authenticate using their interface. Which provider gets contacted is determined by <code>value="@provider.Name"</code>.</p></li>
<li>
<p>After the visitor authenticates using the external provider, the application receives information about the user, and can:</p>
<ol type="1">
<li>Create an account for them in the database.</li>
<li>Create and bind the used external provider to the created account (to identify and match further sign-in attempts from the user).</li>
</ol>
</li>
</ol>
<p>The following code continues the Google authentication example from the previous section. However, the code can be reused by any external provider.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>External authentication flow</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

public class AccountController : Controller
{
    private readonly IEventLogService eventLogService;
    private readonly UserManager&lt;ApplicationUser&gt; userManager;
    private readonly SignInManager&lt;ApplicationUser&gt; signInManager;

    // Gets required services using dependency injection
    public AccountController(UserManager&lt;ApplicationUser&gt; userManager,
                             SignInManager&lt;ApplicationUser&gt; signInManager,
                             IEventLogService eventLogService)
    {
        this.userManager = userManager;
        this.signInManager = signInManager;
        this.eventLogService = eventLogService;
    }

    // Redirects authentication requests to an external service
    [HttpPost]
    [ValidateAntiForgeryToken]
    public IActionResult RequestExternalSignIn(string provider)
    {
        // The URL to redirect to after successful authentication
        string redirectUrl = Url.Action(nameof(ExternalSignInCallback));

        // Configures the redirect URL and user identifier 
        // for the specified external authentication provider
        AuthenticationProperties authenticationProperties =
            signInManager.ConfigureExternalAuthenticationProperties(provider, redirectUrl);

        // Challenges the specified authentication provider
        return Challenge(authenticationProperties, provider);
    }

    // Processes the response from external providers
    [HttpGet]
    public async Task&lt;IActionResult&gt; ExternalSignInCallback(string remoteError = null)
    {

        // Extracts login info out of the external identity provided by the service
        ExternalLoginInfo loginInfo = await signInManager.GetExternalLoginInfoAsync();

        // If the external authentication fails, displays a view with appropriate information
        if (loginInfo == null)
        {
            return RedirectToAction(nameof(ExternalAuthenticationFailure));
        }

        // Synchronizes the external account with Xperience's database
        await SynchronizeExternalAccount(loginInfo);

        return Redirect($"/");
    }

    private async Task SynchronizeExternalAccount(ExternalLoginInfo loginInfo)
    {
        var providerKey = loginInfo.ProviderKey;

        // If the external login doesn't exists in the database either a new
        // visitor is signing in or an existing visitor is signing in using a different provider
        if (await userManager.FindByLoginAsync(loginInfo.LoginProvider, providerKey) == null)
        {
            // Gets an email from external claims
            var email = loginInfo.Principal.FindFirstValue(ClaimTypes.Email);

            // Checks whether the account already exists
            // Uses the email address as a common link among multiple providers
            var user = await userManager.FindByEmailAsync(email);
            var login = new UserLoginInfo(loginInfo.LoginProvider, providerKey, null);

            if (user != null)
            {
                // If the account already exists the visitor is using a different 
                // external provider. Bind the new external login to an existing account.
                await userManager.AddLoginAsync(user, login);
                await SignInExternal(loginInfo);
            }
            else
            {
                // Otherwise, a completely new visitor is signing in.
                // Create their account and corresponding external login.

                // Creates the user object
                user = new ApplicationUser
                {
                    // Accounts must be enabled to be granted access to the system
                    // For external accounts, it is safe to always set this property to true
                    // without implementing additional verification measures.
                    // The external provider ensures authenticity of the received data.
                    Enabled = true,
                    Email = email,
                    UserName = email,
                    // Flag to identify external accounts
                    IsExternal = true
                };

                // Creates the user account
                await userManager.CreateAsync(user);
                // Binds the external login to the created account
                await userManager.AddLoginAsync(user, login);
                await SignInExternal(loginInfo);
            }
        }
        // Otherwise, sign in the visitor
        else
        {
            await SignInExternal(loginInfo);
        }
    }

    private async Task SignInExternal(ExternalLoginInfo loginInfo)
    {
        // Attempts to sign in the user using the external login info
        SignInResult result = 
            await signInManager.
                ExternalLoginSignInAsync(loginInfo.LoginProvider, loginInfo.ProviderKey, true);

        // Success occurs if the user already exists in the connected database
        // and has signed in using the given external service
        if (result.Succeeded)
        {
            eventLogService.LogInformation("External authentication",
                "EXTERNALAUTH", $"Visitor signed in via {loginInfo.LoginProvider}.");
        }
        else
        {
            eventLogService.LogError("External authentication",
                "EXTERNALAUTH", $"External sign in error.");
        }
    }

    public IActionResult ExternalAuthenticationFailure()
    {
        return View();
    }
}

</code></pre>
</div>


<div>

</div>
<div>
<p><strong>Enabling created accounts</strong></p>
<p>When creating <code>ApplicationUser</code> objects for new external registrations, always set the object’s <code>Enabled</code> property to <code>true</code>. The property controls whether the account can sign in to the system. See <a href="/documentation/developers-and-admins/development/registration-and-authentication#applicationuser.enabled">Remarks - ApplicationUser.Enabled</a> for more information.</p>
</div>

<h2 id="authentication-scopes-and-claims-mapping">Authentication scopes and claims mapping</h2>
<p><a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1#key-concepts-scopes-claims-and-response-types" target="_blank">Claims</a> are key-value pairs that contain verified information about a user. In the OAuth/OIDC authentication flow, claims are sent by the identity provider within ID Tokens. Generally, these tokens are processed by the application, and the information is mapped to some internal representation. In Xperience, this is the <code>MemberInfo</code> object (for more information about Xperience’s Identity architecture, see <a href="/documentation/developers-and-admins/development/registration-and-authentication">Registration and authentication</a>).</p>
<p>To facilitate working with claims, use the <code>ClaimTypes</code> class that provides the most common OIDC-compliant claim key identifiers in an easily accessible format. For example, <code>ClaimTypes.Email</code> resolves to the name of a key under which the user’s email should be stored in the ID token received by the application.</p>
<p>What claims get included in ID tokens is controlled by <strong>authentication scopes</strong>. Authentication scopes are sent together with the authentication request.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Program.cs - request additional claims from the provider</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

builder.Services.AddAuthentication()
        .AddGoogle(googleOptions =&gt;
            {
                googleOptions.ClientId = "&lt;Google_App_ID&gt;";
                googleOptions.ClientSecret = "&lt;Google_App_Secret&gt;";
                // Requests a claim containing the user's birthday
                googleOptions.Scope.Add("https://www.googleapis.com/auth/user.birthday.read");
            });

</code></pre>
</div>

<p>See the documentation of your chosen provider for a list of available scopes. The OAuth/OIDC specification doesn’t enforce any scope naming policies.</p>
<p>In most cases, the Xperience application registration on the provider’s end must also explicitly enable all additional scopes requested by the app. For Google, this is done in the <a href="https://developers.google.com/workspace/guides/configure-oauth-consent" target="_blank">OAuth consent screen configuration</a>. When signing in, visitors are notified about the information your application requests. The enabled scopes directly affect this consent screen.</p>
<p></p>
<p>With the additional claims now being returned as part of ID tokens, you can map the information to the visitor’s account in Xperience.</p>
<ol type="1">
<li>Prepare additional fields to hold your data. See <a href="/documentation/developers-and-admins/development/registration-and-authentication/add-fields-to-member-objects">Add fields to member objects</a>.</li>
<li>Map received claims to the added fields.</li>
</ol>
<p>The following sample demonstrates a class extended with the <code>FirstName</code> property. You can extend the mapping logic within the sample <a href="#implement-the-authentication-flow">AccountController.SynchronizeExternalAccount</a> method.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Map claims to fields</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

user = new ExtendedApplicationUser
{
    Enabled = true,
    Email = email,
    IsExternal = true,
    // Maps the user's first name from the returned claims
    FirstName = loginInfo.Principal.FindFirstValue(ClaimTypes.GivenName)
};

</code></pre>
</div>

<h2 id="general-security-considerations">General security considerations</h2>
<p>When configuring external authentication for your projects, consider the following practices and recommendations.</p>
<h3 id="use-https">Use HTTPS</h3>
<p>Always communicate with the external provider using <strong>HTTPS</strong> to reduce the probability of a third-party obtaining unencrypted sensitive information about your application and users. This generally applies when configuring callback/redirect URIs and additional features such as sign-out redirects for your application on the provider’s end.</p>
<h3 id="use-token-expiration">Use token expiration</h3>
<p>Access tokens should have an expiration time to limit the lifetime of the token and reduce the risk of unauthorized access. You can set the lifetime of authentication cookies when configuring Identity for your application.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Program.cs - Set authentication cookie expiration</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

builder.Services.ConfigureApplicationCookie(options =&gt;
    {
        options.ExpireTimeSpan = TimeSpan.FromMinutes(60);
    });

</code></pre>
</div>

<h3 id="use-a-separate-application-registration-per-physical-application">Use a separate application registration per physical application</h3>
<p>Always make sure to register and configure a new application on the side of your external provider for each separate project you plan to integrate. This approach provides the following benefits:</p>
<ol type="1">
<li>Isolation of access: You allow for more granular control over access to each application. For example, if a client secret for one application is compromised, it would not affect the other applications.</li>
<li>Least Privilege: You can assign only the minimal set of permission required by each application, reducing the risk of privilege escalation.</li>
<li>Auditing and tracking: Tracking and auditing access to each application is easier. This can help identify and investigate suspicious activity.</li>
<li>Easy Revocation: It is easier to revoke or modify the access of one application while keeping the access privileges of other applications intact.</li>
</ol>
<h2 id="securely-store-application-secrets">Securely store application secrets</h2>
<p>As a general security best practice, it is not recommended to store application secrets directly in code or application settings. Instead, consider using the following alternatives.</p>
<h3 id="during-development">During development</h3>
<p>When implementing and testing external authentication locally, use the <a href="https://learn.microsoft.com/en-us/aspnet/core/security/app-secrets" target="_blank">Secrets Manager</a> utility provided by <code>dotnet</code>. The utility abstracts key management and storage. However, note that keys stored using the manager are not encrypted – use this approach only for local development.</p>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>Store a secret</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

cd "C:\my\xperience\WebApp\"

# Initialize the Secrets Manager
dotnet user-secrets init

# Stores a secret for local development
dotnet user-secrets set "Project:ExternalAuthProvider" "12345"

</code></pre>
</div>


<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Read a stored secret</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

var builder = WebApplication.CreateBuilder(args);
...
// Reads the secret and stores it in a variable
var externalAuthApiKey = builder.Configuration["Project:ExternalAuthProvider"];

</code></pre>
</div>

<h3 id="on-production-sites">On production sites</h3>
<p>When deploying production sites, consider the following options:</p>
<h4 id="sites-hosted-on-microsoft-azure">Sites hosted on Microsoft Azure</h4>
<ul>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration#secret-storage-in-the-production-environment-with-azure-key-vault" target="_blank">Azure KeyVault</a></li>
</ul>
<h4 id="private-cloud-hosting">Private cloud hosting</h4>
<ul>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection" target="_blank">DataProtection API</a></li>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/security/key-vault-configuration#use-application-id-and-x509-certificate-for-non-azure-hosted-apps" target="_blank">Azure KeyVault</a></li>
</ul>

</body>
</html>
