<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Retrieve page content</title>
</head>
<body>
<p>Web page content is stored in the database and <a href="/documentation/business-users/website-content">edited</a> through the administration interface using the content tree in <a href="/documentation/business-users/website-content/edit-and-publish-pages">website channel applications</a>.</p>
<p>The Xperience API allows you to work with pages using:</p>
<ul>
<li>
<a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects">Generated content type classes</a> (recommended) – classes generated by the system that allow you to work with <a href="/documentation/developers-and-admins/development/content-types">content type</a> fields using strongly-typed objects. These classes also allow access to all general page data (page title, ID, GUID, creation date, publish date, etc.).</li>
<li>
<a href="/documentation/developers-and-admins/api/content-item-api">Custom data transfer objects</a> (advanced use case) – using custom DTOs grants you control over the mapping logic. See <a href="/documentation/developers-and-admins/api/content-item-api#using-getresult-methods">Map using GetResult&lt;TModel&gt;</a>
</li>
</ul>
<p>The implementation and complexity of the retrieval and management code depend on your preferences and project requirements, and can range from simple method calls within controller actions to custom solutions utilizing repository and service patterns. Install the <a href="/documentation/developers-and-admins/installation#available-project-templates">sample Dancing Goat</a> project to view a reference implementation.</p>
<h2 id="retrieve-page-data">Retrieve page data</h2>
<p>To retrieve web page content, use the following services from <code>CMS.ContentEngine</code> and <code>CMS.Websites</code> namespaces:</p>
<ul>
<li>
<code>ContentItemQueryBuilder</code> class with the <code>ForWebsite</code> query parametrization method – to create and parametrize a <a href="/documentation/developers-and-admins/api/content-item-api">content item query</a> specifically for retrieving website data. The <code>ForWebsite</code> query parameter has the following properties:
<ul>
<li>
<code>websiteChannelName</code> – code name of the website channel from which the pages are retrieved. You can use <a href="#access-context-of-the-current-channel">current channel context</a> to retrieve this value.</li>
<li>
<code>pathMatch</code> – a parameter of type <code>PathMatch</code> used to limit the retrieved pages based on their positon in the website’s content tree. See <a href="#filter-pages-based-on-content-tree-structure">Filter pages based on content tree structure</a> for more information.</li>
<li>
<code>includeUrlPath</code> – indicates if the URLs of pages and <a href="/documentation/developers-and-admins/development/content-retrieval/retrieve-content-items">content item assets</a> are fetched as well. Defaults to <code>true</code>.</li>
</ul>
</li>
<li>
<code>IContentQueryExecutor</code> interface and its <code>GetMappedWebPageResult</code> method – to execute a page query specified by the builder and map the results to the model class.
<ul>
<li>To retrieve correct version of pages in preview mode and Page Builder, modify the query execution by <a href="#retrieve-pages-for-preview">configuring</a> the <code>ContentQueryExecutionOptions</code>.</li>
</ul>
</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Sample page retrieval</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Services obtained via dependency injection
private readonly IContentQueryExecutor executor;

public async Task PageRetrieval()
{
    // Configures the query builder
    var builder = new ContentItemQueryBuilder()
                        .ForContentType(
                            // Scopes the query to pages of the 'My.ArticlePage' content type
                            "My.ArticlePage",
                            config =&gt; config
                                // Retrieves pages only from the specified channel and path
                                .ForWebsite(
                                    "MyWebsiteChannel",
                                    PathMatch.Children("/Articles"))
                        // Retrieves only English variants of pages
                        ).InLanguage("en");

    // Executes the query and stores the data in generated 'ArticlePage' models
    IEnumerable&lt;ArticlePage&gt; pages = await executor.GetMappedWebPageResult&lt;ArticlePage&gt;(builder);

    // Displays the page data
    foreach(var page in pages)
    {
        Console.WriteLine(page.ArticleTitle);
        Console.WriteLine(page.ArticlePageSummary);
    }
}

</code></pre>
</div>

<h3 id="retrieve-multilingual-page-data">Retrieve multilingual page data</h3>
<p>To retrieve web page content in a specific language, use the InLanguage method and as a parameter provide the language code name as specified in the <strong>Languages</strong> application.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Sample multilingual page retrieval</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Creates a query to retrieve pages in the Spanish language
var builder = new ContentItemQueryBuilder()
                        .ForContentType(
                            // ...
                        ).InLanguage("es");

</code></pre>
</div>

<p>If you omit the method and don’t specify a language, the query returns results in the primary language of the website channel.</p>

<div>

</div>
<div>
<p><strong>Pages in fallback language</strong></p>
<p>If the desired language variant of a page doesn’t exist, the query returns the page data in the <a href="/documentation/developers-and-admins/configuration/languages">fallback language</a>, if fallbacks are configured.</p>
</div>

<h3 id="filter-pages-based-on-content-tree-structure">Filter pages based on content tree structure</h3>
<p>You can set the query to only include pages from a certain section of the content tree or omit pages from a section using the <code>PathMatch</code> parameter of the <code>ForWebsites</code> query parametetrization method. PathMatch expressions can be combined to more accurately specify what pages are included in the query.</p>
<ul>
<li>
<code>Single</code> – only retrieves a single page that corresponds to the specified tree path.
<ul>
<li>E.g., <code>PathMatch.Single(path: "/Articles/Coffee_processing_techniques")</code>
</li>
</ul>
</li>
<li>
<code>Children</code> – recursively retrieves all children of a specified parent page, excluding the parent page from the query. You can also specify a nesting level to limit the depth of recursion.
<ul>
<li>E.g., <code>PathMatch.Children(path: "/Articles", nestingLevel: 3)</code>
</li>
</ul>
</li>
<li>
<code>SkipChildren</code> – recursively exclude all children of a specified parent page from the query, except for the parent page. You can also specify a nesting level to limit the depth of recursion.
<ul>
<li>E.g., <code>PathMatch.SkipChildren(path: "/Articles/Coffee", nestingLevel: 3)</code>
</li>
</ul>
</li>
<li>
<code>Section</code> – recursively retrieves all children of a specified parent page, including the parent page in the query. You can also specify a nesting level to limit the depth of recursion.
<ul>
<li>E.g., <code>PathMatch.Section(path: "/Articles", nestingLevel: 3)</code>
</li>
</ul>
</li>
<li>
<code>SkipSection</code> – recursively exclude all children and the specified parent page from the query. You can also specify a nesting level to limit the depth of recursion.
<ul>
<li>E.g., <code>PathMatch.SkipSection(path: "Articles/Coffee", nestingLevel: 3)</code>
</li>
</ul>
</li>
</ul>

<div>

</div>
<div>
<p><strong>Combine PathMatch expressions</strong></p>
<p>You can combine multiple <code>PathMatch</code> expressions by passing an array as the argument to the <code>ForWebsite</code> method.</p>
<div>
<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - Combine PathMatch expressions</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

var builder = new ContentItemQueryBuilder()
                    .ForContentType(
                        "My.ArticlePage",
                        config =&gt; config
                            .ForWebsite(
                                websiteChannelName: "MyWebsiteChannel",
                                pathMatches: new PathMatch[]{
                                    PathMatch.Children("/Articles"),
                                    PathMatch.SkipSection("/Articles/Coffee_processing_techniques")
                                }
                            )
                    );

</code></pre>
</div>
</div>
</div>

<h3 id="filter-pages-based-on-tags">Filter pages based on tags</h3>
<p>You can limit the retrieval query to only retrieve pages with the specified tags using the <code>WhereContainsTags</code> content item query parametrization method.</p>
<p>See <a href="/documentation/developers-and-admins/development/content-retrieval/retrieve-content-items#filter-content-items-based-on-tags">Retrieve content items</a> for more information.</p>
<h3 id="page-security-configuration">Page security configuration</h3>
<p>Pages can be <a href="/documentation/business-users/website-content/secure-pages">secured</a> to allow access only to <a href="/documentation/developers-and-admins/development/registration-and-authentication">authenticated users</a>. You can filter out secured pages during retrieval by passing the appropriate bool value to the <code>IncludeSecuredItems</code> property of the <code>ContentQueryExecutionOptions</code> and providing them to the query executor.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieve secured pages</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Services obtained via dependency injection
private readonly IContentQueryExecutor executor;

// Information about whether to include secured items in the query execution passed from the caller
public async Task PageRetrieval(bool includeSecuredItems)
{
    // Configures the query builder
    var builder = new ContentItemQueryBuilder()...;

    // Configures the query options for the query executor
     var queryOptions = new ContentQueryExecutionOptions()
    {
         IncludeSecuredItems = includeSecuredItems
    };

    // Executes the query and stores the data in generated 'ArticlePage' models
    IEnumerable&lt;ArticlePage&gt; pages = await executor.GetMappedWebPageResult&lt;ArticlePage&gt;(
                                                builder: builder,
                                                options: queryOptions);
}

</code></pre>
</div>

<p>The secured state of a retrieved page is indicated by its <code>page.SystemFields.ContentItemIsSecured</code> property. You can use this property to display information to visitors accordingly.</p>
<p>For example, you can pass the page’s <code>ContentItemIsSecured</code> property to a model and display an appropriate message to visitors. </p>

<div>
<div>
<div>
<span>cshtml</span>
</div>
<strong>Reflect page security in views</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// In this case, the 'ContentItemIsSecured' is mapped to the 'IsSecured' property of this view model 
@if (model.IsSecured &amp;&amp; !User.Identity.IsAuthenticated)
{
    &lt;p&gt;
        Sign in to access this page
    &lt;/p&gt;
}

</code></pre>
</div>

<p>An alternative popular practice is to display a blurred teaser image overlaid with a lock to indicate elevated permission requirements.</p>
<p>You can check whether the current <code>ClaimsPrincipal</code> is authenticated via <code>User.Identity.IsAuthenticated</code>. If unauthenticated visitors attempt to access a secured page, the server returns HTTP 403 Forbidden. ASP.NET Identity can be configured to automatically redirect such requests to another location on the website (typically a registration or sign in page) via <code>AccessDeniedPath</code>.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Program.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

builder.Services.ConfigureApplicationCookie(options =&gt;
{
    // Responses that would otherwise return 403 are instead redirected to &lt;domain&gt;/account/signin
    options.AccessDeniedPath = new PathString("/account/signin");
});

</code></pre>
</div>

<h2 id="work-with-retrieved-page-data">Work with retrieved page data</h2>
<p>You can access various types of data from retrieved page objects:</p>
<ul>
<li>Content type fields – the data that is editable in a page’s <em>Content</em> view mode. The set of available fields is configurable via the <a href="/documentation/developers-and-admins/customization/field-editor">field editor</a>.</li>
<li>System fields – available under the <code>SystemFields</code> property of the retrieved page objects. Access <code>WebPage*</code> fields for web page data and <code>ContentItem*</code> for data of the underlying content item.</li>
<li>Page URL – see <a href="/documentation/developers-and-admins/development/content-retrieval/retrieve-page-content/retrieve-page-urls">Retrieve page URLs</a>.</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Access page data</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Retrieves a page
var page = (await executor.GetMappedWebPageResult&lt;Article&gt;(builder)).FirstOrDefault();

// Accesses the ID of the parent
var parentId = page.SystemFields.WebPageItemParentID;

// Accesses the code name of the page object
var pageName = page.SystemFields.WebPageItemName;

</code></pre>
</div>

<h3 id="access-page-field-data">Access page field data</h3>
<p>The fields available in a page’s <em>Content</em> view mode are specific to its <a href="/documentation/developers-and-admins/development/content-types">content type</a>. You can see the fields that each content type uses:</p>
<ul>
<li>In <strong>Content types</strong> (application) → edit a content type → <strong>Fields</strong> tab</li>
<li>In the corresponding <em>&lt;namespace&gt;_&lt;content_type_name&gt;</em> database table</li>
</ul>
<p>You can access specific fields of a content type directly using strongly typed properties when using <a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects">generated content type classes</a>:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Access content type fields</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Retrieves a page
var page = (await executor.GetMappedWebPageResult&lt;Article&gt;(builder)).FirstOrDefault();

// Accesses the 'Text' field of the page
var pageText = page.ArticlePageText;

// Accesses the 'Teaser' field of the page
var pageImage = page.ArticlePageTeaser.FirstOrDefault();

</code></pre>
</div>


<div>

</div>
<div>
<p><strong>Resolving HTML tags and relative URLs</strong></p>
<p>Fields which are populated by the <strong>Rich text editor</strong> form component may contain HTML tags and relative links. To ensure that the content is displayed correctly when rendered in Razor views, use the <code>Html.Raw</code> method, which disables HTML encoding for the values.</p>
<div>
<div>
<div>
<div>
<span>cshtml</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

@Html.Raw(Model.&lt;RichTextFieldProperty&gt;)

</code></pre>
</div>
</div>
</div>


<div>

</div>
<div>
<p><strong>Automatic URL resolving</strong></p>
<p>The system provides page output filtering functionality that automatically resolves all virtual relative URLs to their absolute form. This filter ensures that links added by content editors into page content work correctly, even if you do not explicitly handle URL resolving in your code.</p>
</div>

<h3 id="date-and-time-fields">Date and time fields</h3>
<p><code>DateTime</code> fields and system properties of retrieved pages always have values in the time zone of the server where the application is running. If you wish to display values in a different time zone (e.g., in a website visitor’s local time), perform a <a href="https://learn.microsoft.com/en-us/dotnet/standard/datetime/converting-between-time-zones" target="_blank">time conversion</a> using the standard .NET API.</p>
<h2 id="access-context-of-the-current-request">Access context of the current request</h2>
<p>Xperience by Kentico provides interfaces that help you access information about the current context.</p>
<h3 id="access-context-of-the-current-channel">Access context of the current channel</h3>
<p>To retrieve information about the website channel context of the current request, use an instance of the <code>IWebsiteChannelContext</code> interface (e.g., obtained via <a href="/documentation/developers-and-admins/development/website-development-basics/dependency-injection">dependency injection</a>) from the <code>CMS.Websites.Routing</code> namespace.</p>
<p>Access the following properties:</p>
<ul>
<li>
<code>WebsiteChannelID</code> – the ID of the current website channel.</li>
<li>
<code>WebsiteChannelName</code> – code name of the current website channel.</li>
<li>
<code>IsPreview</code> – a boolean value that, if <code>true</code>, signifies whether the current request is made in preview (Page Builder or the preview mode in a website channel application).</li>
</ul>
<h3 id="access-current-preferred-language">Access current preferred language</h3>
<p>To retrieve the preferred language of the current request, use the <code>Get</code> method of the <code>IPreferredLanguageRetriever</code> interface (e.g., obtained via <a href="/documentation/developers-and-admins/development/website-development-basics/dependency-injection">dependency injection</a>) .</p>
<p>Note that the preferred language of the request can be different from the actual language of the retrieved content. For example, if language variant of a page does not exist in the preferred language, <a href="/documentation/developers-and-admins/configuration/languages">fallback</a> language variant is retrieved.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieve currently preferred language</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// An instance of  IPreferredLanguageRetriever (e.g., obtained via dependency injection)
private readonly IPreferredLanguageRetriever preferredLanguageRetriever;

// Retrieves the code name of the preferred language
string languageName = preferredLanguageRetriever.Get();

</code></pre>
</div>

<h2 id="retrieve-pages-for-preview">Retrieve pages for preview</h2>
<p>Whenever you work with pages within a website channel application, the system retrieves a given page from the database. Therefore, in order for the <a href="/documentation/business-users/website-content">preview mode and Page Builder</a> to work as expected, it is crucial that the query executor retrieves the page according to the context in which the query is executed:</p>
<ul>
<li>For the live site, retrieve the published versions of the page according to the validity of security claims upon page request.</li>
<li>For preview and Page Builder, retrieve the page in the latest available version regardless of the workflow state and regardless whether it is secured or not.</li>
</ul>
<p>You can achieve this by configuring the <code>ContentQueryExecutionOptions</code> and providing them to the query executor.</p>
<p>In order to distinguish whether the query executor needs to retrieve the page for preview, you can make use of the <code>IsPreview</code> <a href="#access-context-of-the-current-channel">property</a> of <code>IWebsiteChannelContext</code> described above.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieve pages for preview</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Services obtained via dependency injection
private readonly IContentQueryExecutor executor;
private IWebsiteChannelContext websiteChannelContext;

// Information about whether to include secured items in the query execution passed from the caller
public async Task PageRetrieval(bool includeSecuredItems)
{
    // Configures the query builder
    var builder = new ContentItemQueryBuilder()...;

    // Configures the query options for the query executor
    var queryOptions = new ContentQueryExecutionOptions();
    {
        ForPreview = websiteChannelContext.IsPreview,
        IncludeSecuredItems = includeSecuredItems || websiteChannelContext.IsPreview
    };

    // Executes the query and stores the data in generated 'ArticlePage' models
    IEnumerable&lt;ArticlePage&gt; pages = await executor.GetMappedWebPageResult&lt;ArticlePage&gt;(
                                                builder: builder,
                                                options: queryOptions);
}

</code></pre>
</div>

<h3 id="add-preview-context-to-urls">Add preview context to URLs</h3>
<p>You may encounter problems in Preview mode on pages that send requests to a custom API endpoint, which uses <code>IWebsiteChannelContext</code> to <a href="#access-context-of-the-current-channel">access the current channel</a> in its implementation. To ensure that such endpoints work correctly in Preview mode, you need to add preview context data to the endpoint URL.</p>

<div>
<div>
<div>
<span>cshtml</span>
</div>
<strong>Example</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

@using Kentico.Content.Web.Mvc

const endpointUrl = @Url.Kentico().ApplyPreviewContext("url");

</code></pre>
</div>

<p>The <code>ApplyPreviewContext</code> Razor extension method adds various parameters to the endpoint URL, which ensure that <code>IWebsiteChannelContext</code> is able to identify the channel, where the previewed page belongs, regardless of the domain used to access the admin UI.</p>
<h2 id="retrieve-folders">Retrieve folders</h2>
<p>To retrieve the folders from the content tree of a website channel (e.g., to create a page under the folder), use the <code>Retrieve</code> method of the <code>IWebPageFolderRetriever</code> interface (e.g., obtained via <a href="/documentation/developers-and-admins/development/website-development-basics/dependency-injection">dependency injection</a>).</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieve folders</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

// Services obtained via dependency injection
private readonly IWebPageFolderRetriever folderRetriever;
private readonly IWebsiteChannelContext channelContext;

// Retrieves a folder from the specified path
WebPageFolder folder = (await folderRetriever.Retrieve(channelContext.WebsiteChannelName, PathMatch.Children("/Articles"))).FirstOrDefault();

// Use the WebPageFolder object to access information about the folder
int id = folder.ContentItemID;

</code></pre>
</div>


</body>
</html>
