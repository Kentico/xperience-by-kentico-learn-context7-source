<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Content item asset upload API</title>
</head>
<body>
<p>The system provides a supporting API for managing content item asset binaries (for content items with <em>Content item asset</em> <a href="/documentation/developers-and-admins/customization/field-editor">fields</a>). When creating or updating asset binaries, you control where the data is sourced via the <code>IContentItemAssetSource</code> interface and its implementations.</p>
<p>You can use the following default implementations:</p>
<ol type="1">
<li>
<code>ContentItemAssetFileSource</code> – sources the binary data from a location on the file system. When constructing this source, provide:
<ol type="1">
<li>filePath – the location of the asset binary.</li>
<li>canMove – if true, moves the file from the source location to the <em>~/assets</em> folder in the Xperience application instead of creating a copy.</li>
</ol>
</li>
<li>
<code>ContentItemAssetStreamSource</code> – sources the binary from a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.io.stream" target="_blank">Stream</a>. When constructing this source, provide:
<ol type="1">
<li>Func&lt;Task&lt;Stream&gt;&gt; – a delegate that returns the <code>Stream</code> object.</li>
</ol>
</li>
</ol>
<p>The source is passed when constructing <code>ContentItemAssetMedataWithSource</code> objects that are used when updating or creating <code>ContentItemData</code> (the class responsible for populating content item fields) via <code>IContentItemManager</code>.</p>
<p>The following excerpt only demonstrates <code>IContentItemAssetSource</code> instantiation and usage. See the <a href="/api/content-management/content-items">Content items</a> API examples for full code samples.</p>

<div>

</div>
<div>
<p>Use the <a href="/documentation/developers-and-admins/api/files-api-and-cms-io">files API</a> that can be found in the <strong>CMS.IO</strong> namespace instead of the default <strong>System.IO</strong> library to ensure compatibility with various types of storage providers.</p>
</div>


<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ContentItemAssetFileSource usage</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using CMS.IO;

// ...

// Gets the metadata for content item creation
CreateContentItemParameters createParams = //...

// Gets the file information from a file on the file system
var assetPath = "C:/data/images/store-logo.jpg";
var file = FileInfo.New(assetPath);

// Creates a metadata object that describes the uploaded asset
var assetMetadata = new ContentItemAssetMetadata()
{
    Extension = file.Extension,
    Identifier = Guid.NewGuid(),
    LastModified = DateTime.Now,
    Name = file.Name,
    Size = file.Length
};

// Creates a 'ContentItemAssetFileSource' object used to locate the asset and merges it with the metadata object
var fileSource = new ContentItemAssetFileSource(file.FullName, false);
var assetMetadataWithSource = new ContentItemAssetMetadataWithSource(fileSource, assetMetadata);

// Passes the metadata and the binary source to ContentItemData
ContentItemData itemData = new ContentItemData(new Dictionary&lt;string, object&gt;{
    { "StoreLogo", assetMetadataWithSource }
});

// Creates the content item 
await contentItemManager.Create(createParams, itemData);

</code></pre>
</div>

<h3 id="custom-implementations">Custom implementations</h3>
<p>You can also provide custom implementations of <code>IContentItemAssetSource</code> that retrieve the binary data according to your preference.</p>
<p>The interface requires the following members:</p>
<ul>
<li>
<strong>HasData</strong> – a boolean property that determines whether the source carries updated binary data. If false, the asset binary is not updated in the <em>~/assets</em> folder on the file system when updating the corresponding content item.</li>
<li>Task <strong>Write</strong>(string targetAssetFilePath, CancellationToken cancellationToken) – method that writes the binary data to <code>targetAssetFilePath</code>. Invoked by the system when processing management operations over asset binaries.</li>
</ul>
<p>The following sample implementation sources the asset binary from a URI:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ContentItemAssetUriSource.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

using System;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;

using CMS.ContentEngine;
using CMS.IO;

public class ContentItemAssetUriSource : IContentItemAssetSource, IDisposable
{
    private static readonly HttpClient httpClient = new HttpClient();
    private Uri assetUri;
    private HttpContent assetContent;

    // Determines whether the asset binary should be updated.
    // Always set to true - the system assumes fresh binary data every time 
    // an instance of this class is provided.
    public bool HasData =&gt; true;

    public ContentItemAssetUriSource(string assetUri)
    {
        this.assetUri = new Uri(assetUri);
    }

    // Gets meta information about the asset
    public async Task&lt;ContentItemAssetMetadata&gt; GetAssetMetadata(CancellationToken cancellationToken = default)
    {
        await EnsureAssetContent(cancellationToken);

        return new ContentItemAssetMetadata()
        {
            Extension = Path.GetExtension(assetUri.LocalPath),
            Identifier = Guid.NewGuid(),
            LastModified = DateTime.UtcNow,
            Name = Path.GetFileName(assetUri.LocalPath),
            Size = assetContent.Headers.ContentLength.GetValueOrDefault()
        };
    }

    // Writes the asset binary from the Http request to the file system.
    // Invoked by Xperience from within content item management operations (IContentItemManager).
    public async Task Write(string targetAssetFilePath, CancellationToken cancellationToken = default)
    {
        await EnsureAssetContent(cancellationToken);

        // Creates the target file path if it doesn't exist
        CMS.IO.DirectoryHelper.EnsureDiskPath(targetAssetFilePath, string.Empty);

        // Copies the asset binary to the target path
        using (var targetStream = File.Open(targetAssetFilePath, FileMode.Create, FileAccess.Write))
        {
            var assetStream = await assetContent.ReadAsStreamAsync(cancellationToken);
            await assetStream.CopyToAsync(targetStream, cancellationToken);
        }
    }

    private async Task EnsureAssetContent(CancellationToken cancellationToken = default)
    {
        if (assetContent == null)
        {
            var response = await httpClient.GetAsync(assetUri, cancellationToken);

            assetContent = response.Content;
        }
    }

    public void Dispose()
    {
        assetContent?.Dispose();
    } 
}

</code></pre>
</div>


</body>
</html>
