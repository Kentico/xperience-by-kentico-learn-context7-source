<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Decorate system services</title>
</head>
<body>
<p>The <a href="https://refactoring.guru/design-patterns/decorator" target="_blank">decorator pattern</a> allows you to add new functionality to an existing object without altering its structure. There are two main ways the decorator pattern can be implemented in Xperience.</p>
<ul>
<li><a href="#decorate-services-via-dependency-injection">Using dependency injection</a></li>
<li><a href="#decorate-services-via-inheritance">Using inheritance</a></li>
</ul>
<h2 id="decorator-pattern-considerations">Decorator pattern considerations</h2>
<p>This section provides general guidelines and recommendations for when to use the decorator pattern.</p>
<p>Consider using the decorator pattern when:</p>
<ul>
<li>extending an existing implementation with new logic while maintaining the original behavior</li>
<li>replacing the implementation of specific members, leaving others unchanged</li>
</ul>
<p>Avoid using the decorator pattern when:</p>
<ul>
<li>completely replacing the implementation of a service class – there is no point in decorating a class if you don’t plan on reusing any of the logic</li>
</ul>
<h2 id="decorate-services-via-dependency-injection">Decorate services via dependency injection</h2>
<p>Xperience service classes registered within the ASP.NET Core application’s Inversion of Control (IoC) container can be decorated by registering a new implementation of the same service (interface) with a constructor dependency on itself. The service container is capable of resolving the previous implementation of the service from within the new one, allowing you to add custom logic to the service’s members.</p>
<p>The benefits of this approach are:</p>
<ul>
<li>the service maintains its behavior, but with added custom logic (e.g., additional logging)</li>
<li>the new implementation gets used in place of the old one automatically across the system</li>
<li>to revert back to the previous implementation, you only need to stop registering the new implementation into the container</li>
<li>opens <code>sealed</code> and <code>internal</code> service implementations for modification</li>
<li>the IoC container always resolves the <em>previous</em> implementation of a service (last registered relative to the implementation being resolved), allowing you to chain multiple decorators</li>
</ul>

<div>

</div>
<div>
<p><strong>Registering multiple decorators for a service from the same assembly</strong></p>
<p>Service registrations from within the same assembly are nondeterministic – the order of registration can be different every time the application starts. If you need to chain multiple decorators from within a single assembly, you can do so via a <a href="/documentation/developers-and-admins/customization/run-code-on-application-startup">custom code-only module</a> class. Override the module’s <code>OnPreInit</code> method, and call <code>Service.Use&lt;TService, TImplementation&gt;()</code> for each of your implementation in the order of dependency. This ensures deterministic ordering for the IoC container.</p>
</div>

<h3 id="example">Example</h3>
<p>The following example demonstrates decoration via dependency injection:</p>
<ol type="1">
<li>
<p>Create a new implementation of the desired service. This example modifies <code>IEventLogService</code> to add more information to the application’s event logging.</p>
<ul>
<li>For best practices about integrating custom code, see <a href="/documentation/developers-and-admins/customization/integrate-custom-code">Integrate custom code</a>.</li>
</ul>
</li>
<li>
<p>Inject the same service via a constructor dependency. When instantiating your service, the container resolves its previous implementation.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using CMS.Core;

 public class EventLogServiceCustomized : IEventLogService
 {
     private readonly IEventLogService eventLogService;

     // Resolves to the previous implementation of the service
     public EventLogServiceCustomized(IEventLogService eventLogService)
     {
         this.eventLogService = eventLogService;
     }
 }

 </code></pre>
</div>
</li>
<li>
<p>Implement the methods prescribed by the interface. To keep the original behavior, call the equivalent methods from the injected service within the corresponding method implementations. Add custom logic as required.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using Microsoft.AspNetCore.Http;

 using CMS.Core;

 public class EventLogServiceCustomized : IEventLogService
 {      

     private readonly IEventLogService eventLogService;
     private readonly IHttpContextAccessor httpContextAccessor;

     public EventLogServiceCustomized(IEventLogService eventLogService,
                                      IHttpContextAccessor httpContextAccessor)
     {
         this.eventLogService = eventLogService;
         this.httpContextAccessor = httpContextAccessor;
     }       

     public void LogEvent(EventLogData eventLogData)
     {
         // Added custom logic that modifies the logged event data      
         eventLogData.EventDescription += $" Action was performed from {httpContextAccessor.HttpContext.Connection.RemoteIpAddress.ToString()}";   
         // Call to the previous implementation of the method to do the actual logging
         eventLogService.LogEvent(eventLogData);
     }
 }

 </code></pre>
</div>
</li>
<li>
<p>Register the service implementation within the application’s IoC container via the <code>RegisterImplementation</code> attribute.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using Microsoft.AspNetCore.Http;

 using CMS;
 using CMS.Core;

 [assembly: RegisterImplementation(typeof(IEventLogService), typeof(EventLogServiceCustomized))]
 public class EventLogServiceCustomized : IEventLogService

 </code></pre>
</div>
</li>
</ol>
<p>The system now uses your service implementation in place of the previous one. The service’s core behavior remains unchanged, but it also executes the additional logic when used.</p>
<h2 id="decorate-services-via-inheritance">Decorate services via inheritance</h2>
<p>Xperience services with public implementations can be decorated via inheritance. This form of customization is only possible for services that</p>
<ul>
<li>expose their implementation</li>
<li>contain virtual members (overridable from derived classes)</li>
</ul>
<h3 id="example-1">Example</h3>
<p>The following example demonstrates decoration via inheritance:</p>
<ol type="1">
<li>
<p>Create a new implementation that inherits from the default implementation of the desired service. This example modifies <code>EventLogService</code> (the implementation of <code>IEventLogService</code>) to add more information to the application’s event logging.</p>
<ul>
<li>For best practices about integrating custom code, see <a href="/documentation/developers-and-admins/customization/integrate-custom-code">Integrate custom code</a>.</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using CMS.EventLog;

 public class EventLogServiceCustomized : EventLogService
 {    
 }

 </code></pre>
</div>
</li>
<li>
<p>Override the virtual members that you wish to decorate. To keep the original behavior, call their base implementation from within the overridden member. Add custom logic as required.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using CMS.EventLog;

 public class EventLogServiceCustomized : EventLogService
 {
     private readonly IHttpContextAccessor httpContextAccessor;

     public EventLogServiceCustomized(IHttpContextAccessor httpContextAccessor)
     {
         this.httpContextAccessor = httpContextAccessor;
     }

     public override void LogEvent(EventLogData eventLogData)
     {
         // Added custom logic that modifies the logged event data
         eventLogData.EventDescription += $" Action was performed from {httpContextAccessor.HttpContext.Connection.RemoteIpAddress}";
         // Call to the default implementation of the method to do the actual logging
         base.LogEvent(eventLogData);
     }
 }

 </code></pre>
</div>
</li>
<li>
<p>Register the new implementation using the <code>RegisterImplementation</code> assembly attribute.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong></strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>

 using CMS;
 using CMS.EventLog;

 [assembly: RegisterImplementation(typeof(IEventLogService), typeof(EventLogServiceCutomized))]
 public class EventLogServiceCustomized : EventLogService

 </code></pre>
</div>
</li>
</ol>
<p>The system now uses your service implementation in place of the default one. The service’s core behavior remains unchanged, but it also executes the additional logic when used.</p>

</body>
</html>
