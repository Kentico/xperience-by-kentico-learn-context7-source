<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Implement the checkout process</title>
</head>
<body>
<p>Most of the checkout process for <a href="/documentation/developers-and-admins/digital-commerce-setup">digital commerce</a> needs to be implemented by developers. This is because checkout requirements (e.g., payment methods, shipping options, tax handling, order confirmation) can vary greatly between projects. The commerce feature provides the core building blocks, but it is up to the development team to customize the checkout process to match the specific needs of the shop.</p>
<p>To implement a checkout process in your commerce solution, you need to handle the following steps:</p>
<ol type="1">
<li><a href="#manage-shopping-cart-data">Store products in the shopping cart</a></li>
<li><a href="#manage-the-current-shopping-cart">Retrieve the current shopping cart</a></li>
<li><a href="#create-orders-from-shopping-carts">Create a new order from the shopping cart</a></li>
</ol>

<div>

</div>
<div>
<p><strong>Commerce object types</strong></p>
<p>Object types used by the commerce feature (Shopping cart, Order, Order address, Order item, Customer, Customer address …):</p>
<ul>
<li>are considered live-site data and are not supported by the <a href="/documentation/developers-and-admins/ci-cd">CI/CD</a> feature</li>
<li>can be <a href="/documentation/developers-and-admins/customization/object-types/extend-system-object-types">extended</a> by adding custom fields</li>
</ul>
</div>

<h2 id="manage-shopping-cart-data">Manage shopping cart data</h2>
<p>Shopping carts are represented by <code>ShoppingCartInfo</code> objects in the API. The actual content of a shopping cart is stored in the <code>ShoppingCartData</code> string property. You are responsible for implementing the <a href="/documentation/developers-and-admins/digital-commerce-setup/model-product-catalog">data model</a> and serialization logic for the shopping cart content.</p>
<p>A typical implementation (as in the <a href="/documentation/developers-and-admins/installation#available-project-templates">Dancing Goat</a> project template) uses a <code>ShoppingCartDataModel</code> to represent the cart, containing a collection of <code>ShoppingCartDataItem</code> objects for each product in the cart. This example uses three properties to represent the item ID, quantity, and <a href="/documentation/developers-and-admins/digital-commerce-setup/model-product-catalog#product-variants">variant ID</a>, but your actual implementation may need to reflect the <a href="/documentation/developers-and-admins/digital-commerce-setup/model-product-catalog">content model</a> of your product catalog:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - ShoppingCartDataItem.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Represents a single item in the shopping cart
public class ShoppingCartDataItem
{
    public int ContentItemId { get; set; }
    public int Quantity { get; set; }
    public int? VariantId { get; set; }
}
</code></pre>
</div>


<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - ShoppingCartDataModel.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Represents the shopping cart data model containing all items
public class ShoppingCartDataModel
{
    public ICollection&lt;ShoppingCartDataItem&gt; Items { get; init; } = new List&lt;ShoppingCartDataItem&gt;();
}
</code></pre>
</div>

<p>To store and retrieve the shopping cart data model from the <code>ShoppingCartInfo</code> object, you can implement custom extension methods. You can use a data model and persistence method that fits your requirements; the following example uses JSON serialization for simplicity, but you can use any approach that suits your project.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - ShoppingCartDataModelExtensions.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Provides extension methods for serializing and deserializing the shopping cart data
public static class ShoppingCartDataModelExtensions
{
    public static ShoppingCartDataModel GetShoppingCartDataModel(this ShoppingCartInfo shoppingCart)
    {
        // Deserializes the ShoppingCartData string into a ShoppingCartDataModel instance
        return (string.IsNullOrEmpty(shoppingCart?.ShoppingCartData) ? null : JsonSerializer.Deserialize&lt;ShoppingCartDataModel&gt;(shoppingCart.ShoppingCartData))
            ?? new ShoppingCartDataModel();
    }

    public static void StoreShoppingCartDataModel(this ShoppingCartInfo shoppingCart, ShoppingCartDataModel shoppingCartData)
    {
        // Serializes the ShoppingCartDataModel instance into a JSON string and stores it in ShoppingCartData
        shoppingCart.ShoppingCartData = JsonSerializer.Serialize(shoppingCartData);
    }
}
</code></pre>
</div>

<p>To update the shopping cart (add, update, or remove items), you can use logic similar to the following, as seen in <code>DancingGoatShoppingCartController.cs</code>:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - DancingGoatShoppingCartController.cs (excerpt)</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// An instance of IInfoProvider&lt;ShoppingCartInfo&gt; (e.g., obtained via dependency injection)
private readonly IInfoProvider&lt;ShoppingCartInfo&gt; shoppingCartInfoProvider;

// Updates the quantity of a product in the shopping cart, or adds/removes the item as needed
private void UpdateQuantity(ShoppingCartInfo shoppingCart,
                            int contentItemId,
                            int quantity,
                            int? variantId,
                            bool setAbsoluteValue = false)
{
    // Retrieves the current shopping cart data model
    var shoppingCartData = shoppingCart.GetShoppingCartDataModel();

    // Finds the product item in the cart by content item ID and variant ID
    var productItem = shoppingCartData.Items.FirstOrDefault(
                                x =&gt; x.ContentItemId == contentItemId &amp;&amp; x.VariantId == variantId
                                );
    if (productItem != null)
    {
        // Updates the quantity (absolute or relative)
        productItem.Quantity = setAbsoluteValue ? quantity : Math.Max(0, productItem.Quantity + quantity);
        // Removes the item if the quantity is zero
        if (productItem.Quantity == 0)
        {
            shoppingCartData.Items.Remove(productItem);
        }
    }
    else if (quantity &gt; 0)
    {
        // Adds a new item to the cart if it does not exist and quantity is positive
        shoppingCartData.Items.Add(new ShoppingCartDataItem {
                                        ContentItemId = contentItemId,
                                        Quantity = quantity,
                                        VariantId = variantId
                                        });
    }

    // Serializes and stores the updated shopping cart data model
    shoppingCart.StoreShoppingCartDataModel(shoppingCartData);

    // Stores the updated shopping cart object to the database
    await shoppingCartInfoProvider.SetAsync(shoppingCart);
}
</code></pre>
</div>

<p>This approach allows you to flexibly manage the shopping cart’s contents and persist them as a serialized string in the database.</p>
<p>For a complete example, see the <a href="/documentation/developers-and-admins/installation#available-project-templates">Dancing Goat</a> project template’s shopping cart controller and related models.</p>
<h2 id="manage-the-current-shopping-cart">Manage the current shopping cart</h2>
<p>The current shopping cart is managed using the <code>ICurrentShoppingCart*</code> services, available in the <code>Kentico.Commerce.Web.Mvc</code> namespace. These services provide methods to retrieve, create, and delete shopping carts for the current user session.</p>
<ul>
<li>For anonymous users, the shopping cart identifier is stored in a browser cookie.</li>
<li>For signed-in <a href="/documentation/business-users/members">members</a>, the shopping cart is associated with the member account, ensuring that the cart content is consistent across devices and sessions.</li>
</ul>
<p>The actual shopping cart data is persisted in the database. This allows members to access their cart from any device after signing in. You can also <a href="/documentation/developers-and-admins/digital-commerce-setup#configure-shopping-cart">configure</a> the expiration period after which abandoned shopping carts are deleted.</p>
<p>To work with the current user’s shopping cart, use the following services:</p>
<ul>
<li>
<code>ICurrentShoppingCartRetriever</code> – use the <code>Get</code> method to retrieve the <code>ShoppingCartInfo</code> object for the current user. Returns <code>null</code> if no cart exists.</li>
<li>
<code>ICurrentShoppingCartCreator</code> – use the <code>Create</code> method to create a new <code>ShoppingCartInfo</code> object and store its identifier (in a cookie for anonymous users or linked to the member for signed-in users).</li>
<li>
<code>ICurrentShoppingCartDiscardHandler</code> – use the <code>Discard</code> method to delete the current user’s shopping cart from the database and remove the identifier.</li>
<li>
<code>ICurrentShoppingCartMemberSignInHandler</code> – use the <code>MemberSignIn</code> method to handle the transition from anonymous to member cart during sign-in. If both an anonymous and a member cart exist, the member cart is deleted and the anonymous cart is assigned to the member.</li>
</ul>
<p>The default behavior of these services can be customized by overriding the respective service implementations in your project.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Managing the current shopping cart</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// An instance of ICurrentShoppingCartService (e.g., obtained via dependency injection)
private readonly ICurrentShoppingCartService currentShoppingCartService;

// Retrieves the shopping cart for the current user
ShoppingCartInfo shoppingCart = await currentShoppingCartService.Get();

// If there is no shopping cart for the current user, creates a new shopping cart
shoppingCart ??= await currentShoppingCartService.Create(null);

// Accesses the shopping cart content (e.g., products in the cart) using
// the extensions methods from the previous section.
var cartData = shoppingCart.GetShoppingCartDataModel();

// Deletes the shopping cart for the current user if needed
await currentShoppingCartService.Delete();
</code></pre>
</div>

<h2 id="create-orders-from-shopping-carts">Create orders from shopping carts</h2>
<p>Orders are represented as <code>OrderInfo</code> objects in the API.</p>

<div>

</div>
<div>
<p><strong>Notes</strong></p>
<ul>
<li>It is recommended to implement the checkout process as a separate service, such as <code>OrderService</code>, which handles the logic of creating orders from shopping carts. This service can be injected into your controllers or other components where you need to create orders.</li>
<li>It is recommended to perform the checkout process in a transaction scope (using the <code>CMSTransactionScope</code> class) to ensure that all operations succeed or fail together. This prevents partial updates in case of errors during order creation.</li>
<li>This scenario uses the architecture of the commerce solution in the Dancing Goat project template. You can view a complete example of the order creation process in the <a href="/documentation/developers-and-admins/installation#available-project-templates">Dancing Goat</a> project template’s <code>OrderService.cs</code> file.</li>
</ul>
</div>

<ol type="1">
<li>
<p>Create or retrieve a <code>CustomerInfo</code> object for the current user.</p>
<ul>
<li>
<p>For <a href="/documentation/developers-and-admins/development/registration-and-authentication#retrieve-the-currently-authenticated-member">members</a>, you can use the <code>CustomerMemberID</code> property of the <code>CustomerInfo</code> object to retrieve the respective customer object and ensure that order history is maintained.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieving customer information for existing members</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
  // An instance of IInfoProvider&lt;CustomerInfo&gt; (e.g., obtained via dependency injection)
  private readonly IInfoProvider&lt;CustomerInfo&gt; customerInfoProvider;

  // The member ID of the current user
  int memberId;

  // Retrieves the customer object for the current member
  CustomerInfo customer = (await customerInfoProvider
      .Get()
      .WhereEquals(nameof(CustomerInfo.CustomerMemberID), memberId)
      .TopN(1)
      .GetEnumerableTypedResultAsync(cancellationToken: cancellationToken))
      .FirstOrDefault();
  </code></pre>
</div>
</li>
<li><p>For anonymous users, you need to create a new <code>CustomerInfo</code> object with each order, as they do not have a persistent account.</p></li>
</ul>
</li>
<li><p>Retrieve <a href="#manage-the-current-shopping-cart">current shopping cart</a> and data about <a href="#manage-shopping-cart-data">products contained in the shopping cart</a>.</p></li>
<li>
<p>Calculate the total price and any additional charges (e.g., shipping, taxes).</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - Calculating total price of items in the shopping cart</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
 // Shopping cart content retrieved from the current shopping cart
 ShoppingCartDataModel shoppingCartDataModel;

 // Calculates the total price of items in the shopping cart
 decimal itemsPrice = shoppingCartDataModel.Items
     .Sum(item =&gt; CalculateItemPrice(
         item.Quantity,
         products.First(product =&gt;
             (product as IContentItemFieldsSource).SystemFields.ContentItemID == item.ContentItemId
         ).ProductFieldPrice
     ));

 // Calculation of shipping and tax prices depends on your business logic
 decimal shippingPrice = 0;
 decimal taxPrice = 0;

 decimal totalPrice = itemsPrice + shippingPrice + taxPrice;
 </code></pre>
</div>
</li>
<li>
<p>Create <code>OrderAddressInfo</code> objects for billing address (and shipping address, if necessary).</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Example - Create an order address from customer data</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
 // An instance of IInfoProvider&lt;OrderAddressInfo&gt; (e.g., obtained via dependency injection)
 private readonly IInfoProvider&lt;OrderAddressInfo&gt; orderAddressInfoProvider;

 // The customer data from the checkout form
 CustomerDto customerDto;

 // Creates a billing address object
 var billingAddress = new OrderAddressInfo()
 {
     OrderAddressFirstName = customerDto.FirstName,
     OrderAddressLastName = customerDto.LastName,
     OrderAddressLine1 = customerDto.AddressLine1,
     // ...
     AddressType = "Billing"
 };
 // Saves the billing address object
 await orderAddressInfoProvider.SetAsync(billingAddress);
 </code></pre>
</div>

<ul>
<li>
<p>For members, you can store addresses in the <code>CustomerAddressInfo</code> object linked to the <code>CustomerInfo</code> object. The stored address can be used to pre-fill the checkout form.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Retrieve customer address</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
   // An instance of IInfoProvider&lt;CustomerAddressInfo&gt; (e.g., obtained via dependency injection)
   private readonly IInfoProvider&lt;CustomerAddressInfo&gt; customerAddressInfoProvider;

   // The customer ID of the current customer
   int customerId;

   // Retrieves the address for the current customer
   CustomerAddressInfo customerAddress = (await customerAddressInfoProvider
       .Get()
       .WhereEquals(nameof(CustomerAddressInfo.CustomerID), customerId)
       .TopN(1)
       .GetEnumerableTypedResultAsync(cancellationToken: cancellationToken))
       .FirstOrDefault();
   </code></pre>
</div>
</li>
<li><p>For anonymous users, you need to create a new <code>OrderAddressInfo</code> object from the checkout form data for each order.</p></li>
</ul>
</li>
<li>
<p>Create the <code>OrderInfo</code> object and add <code>OrderItemInfo</code> entries for each product.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Create OrderInfo object</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
 // Instances of required services (e.g., obtained via dependency injection)
 private readonly IInfoProvider&lt;OrderInfo&gt; orderInfoProvider;
 private readonly IInfoProvider&lt;OrderItemInfo&gt; orderItemInfoProvider;
 private readonly IInfoProvider&lt;OrderStatusInfo&gt; orderStatusInfoProvider;

 // Retrieves the ID of the initial order status, in this case the first order status in the system
 var initialOrderStatusId = await orderStatusInfoProvider
           .Get()
           .OrderByAscending(nameof(OrderStatusInfo.OrderStatusOrder))
           .TopN(1)
           .Column(nameof(OrderStatusInfo.OrderStatusID))
           .GetScalarResultAsync&lt;int&gt;(cancellationToken: cancellationToken);

 var order = new OrderInfo()
 {
     OrderCreatedWhen = DateTime.Now,
     OrderNumber = orderNumber, // Generated order number
     OrderCustomerID = customerId,
     OrderTotalPrice = totalPrice,
     OrderShippingAddress = shippingAddress,
     OrderBillingAddress = billingAddress,
     OrderOrderStatusID = initialOrderStatusId,
 };
 await orderInfoProvider.SetAsync(order);

 // Retrieves the shopping cart data model
 var shoppingCartData = shoppingCart.GetShoppingCartDataModel();

 // 
 foreach (var item in shoppingCartData.Items)
 {
     // Retrieves the product by its content item ID
     var product = products.First(product =&gt; (product as IContentItemFieldsSource).SystemFields.ContentItemID == item.ContentItemId);
     // Handles product variants if applicable
     // Handling of product variants depends on your product catalog implementation. This examples uses methods from the Dancing Goat project template.
     var variantSKUs = product == null ? null : productVariantsExtractor.ExtractVariantsSKUCode(product);
     var variantSKU = variantSKUs == null || !item.VariantId.HasValue ? null : variantSKUs[item.VariantId.Value];

     // Creates the order item object
     var orderItem = new OrderItemInfo()
     {
         // Ensures that the order item is linked to the order
         OrderItemOrderID = order.OrderID,
         OrderItemUnitCount = item.Quantity,
         OrderItemUnitPrice = product.ProductFieldPrice,
         OrderItemSKU = variantSKU ?? (product as IProductSKU).ProductSKUCode,
         OrderItemTotalPrice = CalculationService.CalculateItemPrice(item.Quantity, product.ProductFieldPrice),
         // ...
     };
     await orderItemInfoProvider.SetAsync(orderItem);
 }
 </code></pre>
</div>
</li>
<li><p>Trigger a notification to the customer and internal users about the order creation. See <a href="/documentation/developers-and-admins/digital-commerce-setup/configure-order-statuses#send-notifications-for-new-orders">Send notifications for new orders</a> for more information.</p></li>
</ol>
<h2 id="automatically-change-status-of-orders">Automatically change status of orders</h2>
<p>If you have an external system that performs actions that can affect the status of your orders (e.g., shipping company, payment provider), you can automatically update the order status by changing the <code>OrderOrderStatusID</code> property of the <code>OrderInfo</code> object.</p>
<p>The following example showcases a sample code that receives a confirmation of payment from a payment provider and automatically updates the respective order to reflect this change. You would typically call this code in the callback handler of your third-party payment provider integration. When changing order statuses via the API, the <a href="/documentation/developers-and-admins/digital-commerce-setup/configure-order-statuses#configure-notifications-for-order-statuses">notifications</a> are sent as usual.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Change status of an order</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Instance of provider services (e.g., obtained via dependency injection)
private readonly IInfoProvider&lt;OrderInfo&gt; orderInfoProvider;
private readonly IInfoProvider&lt;OrderStatusInfo&gt; orderStatusInfoProvider;

// Order ID received from a payment provider
int orderId;

// Retrieves the order data
OrderInfo order = await orderInfoProvider.GetAsync(orderId, cancellationToken);

// Retrieves data of the new order status
OrderStatusInfo newOrderStatus = await orderStatusInfoProvider.GetAsync("PaymentReceived", cancellationToken);

// Sets the new status to the order data
order.OrderOrderStatusID = newOrderStatus.OrderStatusID;

// Saves the changes of the order data
await orderInfoProvider.SetAsync(order, cancellationToken);
</code></pre>
</div>


</body>
</html>
