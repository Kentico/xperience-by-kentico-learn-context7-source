<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Work with reusable field schemas</title>
</head>
<body>
<p><a href="/documentation/developers-and-admins/development/content-types/reusable-field-schemas">Reusable field schemas</a> are collections of fields that multiple content types can share. When a schema is updated with a new field, for example, any content types that use that snippet will also have the new field.</p>
<p>Beyond this, you can restrict references between content items based on reusable field schemas, or even filter <a href="/documentation/developers-and-admins/api/content-item-api/reference-content-item-query">content item queries</a>, retrieving items of multiple types that share a schema.</p>
<p>Let’s explore this functionality through the lens of a common scenario: content model evolution.</p>
<h2 id="before-you-start">Before you start</h2>
<p>This guide requires the following:</p>
<ul>
<li>Familiarity with <a href="https://learn.microsoft.com/en-us/dotnet/csharp/" target="_blank">C#</a>, <a href="https://learn.microsoft.com/en-us/dotnet/" target="_blank">.NET Core</a>, <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection" target="_blank">Dependency injection</a>, and the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/overview" target="_blank">MVC pattern</a>.</li>
<li>A running instance of Xperience by Kentico, preferably <a href="/documentation/changelog">30.6.2</a> or higher.

<div>

</div>
<div>
Some features covered in the Training guides may not work in older versions.
</div>
</li>
</ul>

<div>
<p><strong>Code samples</strong></p>
<p>You can find a project with completed, working versions of code samples from this guide and others in the <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/tree/finished" target="_blank">finished branch</a> of the <em>Training guides</em> repository.</p>
<p>The <a href="https://github.com/Kentico/xperience-by-kentico-training-guides" target="_blank">main branch</a> of the repository provides a starting point to code along with the guides.</p>
<p>The code samples in this guide are for <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/overview" target="_blank">.NET 8</a> only.</p>
<p>They come from a project that uses <a href="https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives" target="_blank">implicit using directives</a>. You may need to add additional <code>using</code> directives to your code if your project does not use this feature.</p>
</div>

<h2 id="consider-the-scenario">Consider the scenario</h2>
<p>As businesses mature over time, they may need more advanced content models to meet their needs. As a developer on such projects, you’ll have to adapt the code to handle these changes.</p>
<p>In this example, the project is moving from a flat <em>Article</em> content type to a Reusable field schema called <em>Article schema</em>, which is shared between two content types: <em>General article</em> and <em>Interview</em>.</p>
<p></p>
<p>To save you time, the main branch already includes the two new schema-based article types, alongside the old article type. You can see them in the <strong>Content types</strong> application. <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/tree/main/src/TrainingGuides.Entities" target="_blank">Code files</a> for the new types and the schemas have already been <a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects">generated</a>.</p>
<p>However, the code of the site does not yet handle the data from these new types. <em>Interviews</em> and <em>General articles</em> do not display properly on article pages, while the old type does.</p>
<p>Let’s dive into the code, and fix our article service to handle this new content type. Then, at the end, we can add personalization to further enhance the widgets that use it.</p>
<h2 id="examine-the-current-implementation">Examine the current implementation</h2>
<p>In the content tree of the <em>Training guides pages</em> channel, you’ll find eight children under <em>News and articles</em>:</p>
<p>Four pages that display articles of the deprecated type:</p>
<ul>
<li>About reptiles</li>
<li>About birds</li>
<li>About dogs</li>
<li>About cats</li>
</ul>
<p>And four pages referencing schema-based articles that do not display:</p>
<ul>
<li>About frogs</li>
<li>About conifers</li>
<li>Bean plant cultivation: an interview with Jack Trott</li>
<li>Sheep care: an interview with Little Bo-Peep</li>
</ul>
<p></p>
<p></p>
<p>You’ll also notice that these new articles do not display if you use the <em>Article list</em> or <em>Featured article</em> widgets on a page with page builder.</p>
<p>Let’s take a look under the hood to see how article pages are rendered.</p>
<h3 id="check-the-controller">Check the controller</h3>
<p>Visit <em>ArticlePageController.cs</em> in the <em>TrainingGuides.Web/Features/Articles</em> folder.</p>
<p>You can see that the controller retrieves the current <code>ArticlePage</code> using the <code>RetrieveCurrentPage</code> method. Under the hood, this method gets the page based on the current <em>web page data context</em>. To put this into perspective, open the <strong>Content types</strong> app in the Xperience administration. You’ll notice that the new content types, <em>Article (general)</em> and <em>Article (interview)</em> are both reusable types.</p>
<p></p>
<p>The <em>Article page</em> content type contains two fields for selecting content items:</p>
<ul>
<li>
<code>ArticlePageContent</code>, labelled <em>Article page content (DEPRECATED, DO NOT USE)</em> in the admin UI, for selecting items of the deprecated <em>Article</em> content type.</li>
<li>
<code>ArticlePageArticleContent</code>, labelled <em>Article page content</em> in the admin UI, for selecting items that use the new article schema.</li>
</ul>

<div>

</div>
<div>
<p>Since the <em>Article page controller</em> is working with the <em>Article page</em> content type, rather than the reusable types it references, you can leave it alone.</p>
<p>However, notice that it uses an <code>IArticlePageService</code> instance to extract article data into an <code>ArticlePageViewModel</code> object. Let’s inspect this method, <code>ArticlePageService.GetArticlePageViewModel</code>, in the next section.</p>
</div>

<h3 id="dig-into-the-service">Dig into the service</h3>
<p>In the <em>ArticlePageService.cs</em> (from the <em>Services</em> folder that neighbors the controller), you’ll see code that converts the linked <code>Article</code> item from an <code>ArticlePage</code> object and uses it to construct an <code>ArticlePageViewModel</code>.</p>
<p>If we make sure this method accounts for the schema-based articles as well, the template and widgets will be able to display them alongside the deprecated articles.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ArticlePageService.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
...
/// Creates a new instance of &lt;see cref="ArticlePageViewModel"/&gt;, setting the properties using ArticlePage given as a parameter.
/// &lt;/summary&gt;
/// &lt;param name="articlePage"&gt;Corresponding Article page object.&lt;/param&gt;
/// &lt;returns&gt;New instance of ArticlePageViewModel.&lt;/returns&gt;
public ArticlePageViewModel GetArticlePageViewModel(ArticlePage? articlePage)
{
    if (articlePage == null)
    {
        return new ArticlePageViewModel();
    }

    var article = articlePage.ArticlePageContent.FirstOrDefault();
    var articleTeaserImage = article?.ArticleTeaser.FirstOrDefault();

    string articleUrl = articlePage.GetUrl().RelativePath;

    return new ArticlePageViewModel
    {
        Title = article?.ArticleTitle ?? string.Empty,
        SummaryHtml = new HtmlString(article?.ArticleSummary),
        TextHtml = new HtmlString(article?.ArticleText),
        CreatedOn = articlePage.ArticlePagePublishDate,
        TeaserImage = AssetViewModel.GetViewModel(articleTeaserImage),
        Url = articleUrl
    };
}
...
</code></pre>
</div>


<div>

</div>
<div>
<p>The code samples here rely on a <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/blob/main/src/TrainingGuides.Web/Features/Shared/Services/TrainingGuidesWebPageUrlRetriever.cs" target="_blank">decorated version</a> of <code>IWebPageUrlRetriever</code> that includes exception handling.</p>
<p>If you do not plan to use a similar customization, make sure to handle errors that the <code>Retrieve</code> method may throw when it cannot find a page.</p>
</div>

<p>In it’s current state, the <code>GetArticlePageViewModel</code> method does the following:</p>
<ol type="1">
<li>Gets an <code>Article</code> from the provided <code>ArticlePage</code>’s <code>ArticlePageContent</code> property.</li>
<li>Extracts the first <code>Asset</code> object from its <code>ArticleTeaser</code> property.</li>
<li>Retrieves the URL of the provided <code>ArticlePage</code>
</li>
<li>Assembles and returns an <code>ArticlePageViewModel</code> from all of these pieces.</li>
</ol>
<p>Our goal is to have the project display new articles alongside old ones, prioritizing the new ones, so let’s try to get an <code>IArticleSchema</code> from the provided <code>ArticlePage</code> and fall back to the <code>Article</code> only if none is found.</p>
<h2 id="update-the-code">Update the code</h2>
<p>Since we’ll need the URL of the page either way, move the line of code that retrieves it to the beginning.</p>
<p>Then, if the page has an <code>IArticleSchema</code> in its <code>ArticlePageArticleContent</code> collection, assemble and return an <code>ArticlePageViewModel</code> using values from the <code>IArticleSchema</code> instead of the <code>Article</code>.</p>
<p>Outside of the <code>if</code> statement, leave the previous steps to return an <code>ArticlePageViewModel</code> based on the <code>Article</code> type.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ArticlePageService.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre data-line="17-30"><code>
...
/// &lt;summary&gt;
/// Creates a new instance of &lt;see cref="ArticlePageViewModel"/&gt;, setting the properties using ArticlePage given as a parameter.
/// &lt;/summary&gt;
/// &lt;param name="articlePage"&gt;Corresponding Article page object.&lt;/param&gt;
/// &lt;returns&gt;New instance of ArticlePageViewModel.&lt;/returns&gt;
public ArticlePageViewModel GetArticlePageViewModel(ArticlePage? articlePage)
{
    if (articlePage == null)
    {
        return new ArticlePageViewModel();
    }

    string articleUrl = articlePage.GetUrl().RelativePath;
    var articleSchema = articlePage.ArticlePageArticleContent.FirstOrDefault();

    if (articleSchema != null)
    {
        var articleSchemaTeaserImage = articleSchema.ArticleSchemaTeaser.FirstOrDefault();

        return new ArticlePageViewModel
        {
            Title = articleSchema.ArticleSchemaTitle,
            SummaryHtml = new HtmlString(articleSchema?.ArticleSchemaSummary),
            TextHtml = new HtmlString(articleSchema?.ArticleSchemaText),
            CreatedOn = articlePage.ArticlePagePublishDate,
            TeaserImage = AssetViewModel.GetViewModel(articleSchemaTeaserImage),
            Url = articleUrl
        };
    }

    var article = articlePage.ArticlePageContent.FirstOrDefault();
    var articleTeaserImage = article?.ArticleTeaser.FirstOrDefault();

    return new ArticlePageViewModel
    {
        Title = article?.ArticleTitle ?? string.Empty,
        SummaryHtml = new HtmlString(article?.ArticleSummary),
        TextHtml = new HtmlString(article?.ArticleText),
        CreatedOn = articlePage.ArticlePagePublishDate,
        TeaserImage = AssetViewModel.GetViewModel(articleTeaserImage),
        Url = articleUrl
    };
}
...
</code></pre>
</div>

<h2 id="see-the-results">See the results</h2>
<p>Run the project and sign in to the Xperience administration. Now if you visit any of the new articles listed earlier, you should see the article content.</p>
<p></p>
<p>Go to the <strong>Page Builder</strong> tab of the <em>Home</em> page, and click <strong>Edit page</strong></p>
<p>Add an instance of the <em>Featured article</em> widget. Configure the widget to reference one of the new articles.</p>
<p>Then, add an instance of the Article List widget. Set its content tree section to the <em>News and articles</em> page, and save your configuration.</p>
<p>Now you should see both widgets displaying new article content.</p>
<p></p>
<h2 id="add-content-personalization">Add content personalization</h2>
<p>After our changes the widgets are working again. However, we have the opportunity to make them even better.</p>
<p>If we implement <a href="/documentation/developers-and-admins/digital-marketing-setup/content-personalization">content personalization</a>, we can allow editors to show different featured articles to visitors who are members of certain contact groups, based on what is more relevant to them.</p>

<div>

</div>
<div>
<p>To give you an idea of what we are implementing, here is what the process of personalizing widgets looks like for editors:</p>

</div>

<p>Navigate to the <strong>Contact groups</strong> application in the Xperience admin, and define a new contact group with placeholder values for its name and description.</p>
<p>Now, <a href="/documentation/developers-and-admins/digital-marketing-setup/content-personalization/develop-personalization-condition-types">define a new personalization condition type</a> in the <em>TrainingGuides.Web/Features/Personalization</em> folder that allows editors to select a contact group and evaluates whether the current contact is in that group.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>IsInContactGroupConditionType.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
using CMS.ContactManagement;
using CMS.DataEngine;
using TrainingGuides.Web.Features.Personalization;
using Kentico.PageBuilder.Web.Mvc.Personalization;
using Kentico.Xperience.Admin.Base.FormAnnotations;
using Kentico.Xperience.Admin.Base.Forms;

[assembly: RegisterPersonalizationConditionType(
    "TrainingGuides.Web.Features.Personalization",
    typeof(IsInContactGroupConditionType),
    "Is in contact group",
    Description = "Evaluates if the current contact is in one of the contact groups.", IconClass = "icon-app-contact-groups", Hint = "Display to visitors who match at least one of the selected contact groups:")]

namespace TrainingGuides.Web.Features.Personalization;

/// &lt;summary&gt;
/// Personalization condition type based on contact group.
/// &lt;/summary&gt;
public class IsInContactGroupConditionType : ConditionType
{
    /// &lt;summary&gt;
    /// Selected contact group code names.
    /// &lt;/summary&gt;
    [ObjectSelectorComponent(PredefinedObjectType.CONTACTGROUP,
    Label = "Contact groups",
    Order = 0,
    MaximumItems = 0)]
    public IEnumerable&lt;ObjectRelatedItem&gt; SelectedContactGroups { get; set; } = [];

    /// &lt;summary&gt;
    /// Evaluate condition type.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Returns &lt;c&gt;true&lt;/c&gt; if implemented condition is met.&lt;/returns&gt;
    public override bool Evaluate()
    {
        var contact = ContactManagementContext.GetCurrentContact();

        if (contact == null)
        {
            return false;
        }

        if (SelectedContactGroups == null || !SelectedContactGroups.Any())
        {
            return contact.ContactGroups.Count == 0;
        }

        return contact.IsInAnyContactGroup(SelectedContactGroups.Select(c =&gt; c.ObjectCodeName).ToArray());
    }
}
</code></pre>
</div>

<p>Rebuild the solution and access the page builder tab. Now you can define a different featured article that displays for members of your contact group.</p>

<h2 id="whats-next">What’s next?</h2>
<p>The <a href="/guides/development/advanced-content/filter-content-based-on-taxonomies">next guide</a> in this series will cover the process of querying content based on reusable field schemas and taxonomies in order to filter the article list widget by taxonomy term.</p>

</body>
</html>
