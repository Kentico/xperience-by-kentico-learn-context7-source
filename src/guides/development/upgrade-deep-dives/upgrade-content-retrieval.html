<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Upgrade your content retrieval code</title>
</head>
<body>
<p>If you’ve followed along with our <a href="/guides/architecture/upgrade-from-kx13/upgrade-walkthrough">upgrade walkthrough</a>, you’ve already seen several examples of converting <code>IPageRetriever</code> code from Kentico Xperience 13 (KX13) to Xperience by Kentico (XbyK) APIs.</p>
<p>While <code>IPageRetriever</code> was the recommended approach for live sites in KX13, many upgraded KX13 projects still use other methods for retrieving content, such as <code>DocumentHelper</code> and <code>TreeProvider</code>. These options are all built on <code>DocumentQuery</code> and <code>MultiDocumentQuery</code>, and share similar extension methods for parameterization.</p>
<p>We’ve put together some practical examples, inspired by real technical support cases and educational scenarios, to explore how to replicate these KX13 page retrieval scenarios using the <a href="/documentation/developers-and-admins/api/content-item-api/content-retriever-api">ContentRetriever</a> and <a href="/documentation/developers-and-admins/api/content-item-api/content-item-query-api">Content item query</a> APIs.</p>
<h2 id="filter-columns">Filter columns</h2>
<p>Let’s start out with a sample inspired by the <a href="/13/developing-websites/form-builder-development/developing-form-components/using-a-dynamic-data-source-with-selector-components">KX13 documentation</a>.</p>
<p>This example uses <code>DocumentHelper</code>, which by default selects the most recently-edited versions of pages under workflow. This made it ideal for working with preview data in older Kentico versions, but it could also work with published data using the <code>PublishedVersion</code> extension method.</p>
<p>Let’s take a look at the KX13 code:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>KX13</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Get Articles, selecting the latest edited version (DocumentHelper)
var articles = DocumentHelper.GetDocuments("DancingGoatCore.Article") 
    // Filter the results to include children of the "Articles" page
    .Path("/Articles/", PathTypeEnum.Children) 
    // Only retrieve the specified columns
    .Columns("DocumentName", "DocumentGUID") 
    // Specify which site to query pages from
    .OnSite("DancingGoatCore") 
    // Specify the culture (language) version to look for
    .Culture("en-us") 
    // Execute query and get results in enumerable format
    .ToList(); 
</code></pre>
</div>

<p>We can achieve the same result in XbyK using <code>IContentRetriever</code>.</p>
<p>Let’s assume we’ve migrated KX13 pages to a <a href="/documentation/developers-and-admins/configuration/website-channel-management">website channel</a> in XbyK, rather than converting them to reusable items in the <a href="/documentation/business-users/content-hub">Content hub</a>. We’ll also assume that <code>contentRetriever</code> is an instance of <code>IContentRetriever</code> supplied through dependency injection.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
var parameters = new RetrievePagesParameters
{
    // Specify the culture language version to look for
    LanguageName = "en-US", 
    // Ensure the latest edited version of pages under workflow
    IsForPreview = true, 
    // Filter the results to include children of the "Articles" page
    PathMatch = PathMatch.Children("/Articles/"), 
    // Specify which site to query web page items from
    ChannelName = "DancingGoatCore"
};

// Get Articles in enumerable format
var articles = await contentRetriever.RetrievePages&lt;Article&gt;( 
    parameters: parameters,
    additionalQueryConfiguration: query =&gt; query
        // Only retrieve the specified columns
        .Columns(nameof(Article.DocumentName), nameof(Article.SystemFields.ContentItemGUID)), 
    cacheSettings: RetrievalCacheSettings.CacheDisabled
);
</code></pre>
</div>


<div>

</div>
<div>
<p><strong>Optional parameters</strong></p>
<p>Many of the properties specified in <code>RetrievePagesParameters</code>, such as <code>ChannelName</code> and <code>LanguageName</code>, will automatically resolve to relevant values based on the request context. The same applies to similar objects throughout this guide.</p>
</div>

<h2 id="select-items-from-several-content-types">Select items from several content types</h2>
<p>Next, let’s explore a query that selects pages from multiple content types based on a provided set of IDs.</p>
<p>In these examples, assume that <code>idsToSelect</code> is an enumerable set of IDs provided by some API.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>KX13</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Get published versions of pages (TreeProvider)
TreeProvider tree = new TreeProvider(MembershipContext.AuthenticatedUser); 
// Select pages
var pages = Tree.SelectNodes() 
    // Choose only pages whose IDs are in the provided set
    .WhereIn("DocumentID", idsToSelect) 
    // Specify the culture (language) version to look for
    .Culture("en-us") 
    // Specify which site to query pages from
    .OnSite("DancingGoatCore") 
    // Execute query to get results in enumerable format
    .ToList(); 
</code></pre>
</div>

<p>Let’s look at two ways to achieve this in XbyK. First, we’ll use another <code>IContentRetriever</code> instance (<code>contentRetriever</code>) to select from a list of known content types. The resulting <code>IWebPageFieldsSource</code> objects contain valuable information, such as the tree path and URL of the resulting web pages. You can cast these objects into your strongly-typed generated models as needed.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK - ContentRetriever</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Identifiers of all content types we want to query
string[] productContentTypes = {
    DancingGoatCore.Brewer.CONTENT_TYPE_NAME,
    DancingGoatCore.Coffee.CONTENT_TYPE_NAME,
    DancingGoatCore.ElectricGrinder.CONTENT_TYPE_NAME,
    DancingGoatCore.FilterPack.CONTENT_TYPE_NAME,
    DancingGoatCore.ManualGrinder.CONTENT_TYPE_NAME,
    DancingGoatCore.Tableware.CONTENT_TYPE_NAME,
    };

var parameters = new RetrievePagesOfContentTypesParameters
{
    // Specify the language version to look for
    LanguageName = "en-US", 
    // Specify which channel to query pages from
    ChannelName = "DancingGoatCore" 
};

// Retrieve pages in enumerable format
var pages = await contentRetriever.RetrievePagesOfContentTypes&lt;IWebPageFieldsSource&gt;( 
    // Specify the list of content types to query
    contentTypeNames: productContentTypes, 
    parameters: parameters,
    additionalQueryConfiguration: query =&gt; query
    // Choose only pages whose IDs are in the provided set
    .Where(where =&gt; where.WhereIn(nameof(IWebPageFieldsSource.SystemFields.WebPageItemID), idsToSelect)), 
    // Disable caching for demo purposes
    cacheSettings: RetrievalCacheSettings.CacheDisabled 
);
</code></pre>
</div>

<p>If you don’t want to provide a specific list of content types to query, you can use the <code>ContentItemQueryBuilder</code> instead.</p>
<p>For this example, <code>contentQueryExecutor</code> is an instance of <code>IContentQueryExecutor</code>, populated with dependency injection.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK - ContentItemQueryBuilder</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
var builder = new ContentItemQueryBuilder()
    // Retrieve multiple content types, no list necessary
    .ForContentTypes(query =&gt; query 
        .WithLinkedItems(1, options =&gt; options.IncludeWebPageData(true))
        // Specify the channel 
        .ForWebsite("DancingGoatCore")) 
    .Parameters(query =&gt; query
        // Choose only pages whose IDs are in the provided set
        .Where(where =&gt; where.WhereIn(nameof(IWebPageFieldsSource.SystemFields.WebPageItemID), idsToSelect))) 
    // specify language
    .InLanguage("en-US"); 

var queryExecutorOptions = new ContentQueryExecutionOptions
{
    // Get published version of web page items
    ForPreview = false
};

// Retrieve pages in enumerable
var pages = await contentQueryExecutor.GetMappedResult&lt;IWebPageFieldsSource&gt;(builder, queryExecutorOptions);  format

</code></pre>
</div>


<div>

</div>
<div>
<p>The <code>ContentItemQueryBuilder</code> sample here includes a hard-coded language for the sake of illustration.</p>
<p>If you need to <a href="/documentation/developers-and-admins/development/content-retrieval/retrieve-page-content#access-current-preferred-language">resolve the current visitor’s preferred language dynamically</a>, you can inject an instance of <code>IPreferredLanguageRetriever</code>, and call the <code>Get()</code> method.</p>
<p>This happens automatically if you do not supply a language name to <code>IContentRetriever</code>.</p>
</div>

<h2 id="use-a-complex-sorting-condition">Use a complex sorting condition</h2>
<p>Now let’s look at another scenario, based on a support case we received, where products of a certain brand are prioritized.</p>
<p>This KX13 query selects brewers, promoting Hario brewers to the top of the list and sorting the remaining brewers alphabetically.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>KX13</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Retrieve brewers, selecting the latest edited version (DocumentHelper)
var brewers = DocumentHelper.GetDocuments("DancingGoatCore.Brewer") 
    // Specify which site to query pages from
    .OnSite("DancingGoatCore") 
    // Specify the culture (language) version to look for
    .Culture("en-us") 
    // Define a custom sorting order
    .OrderBy("CASE WHEN DocumentName LIKE 'Hario%' THEN 0 ELSE 1 END, DocumentName") 
    // Execute query to get results in enumerable format
    .ToList(); 
</code></pre>
</div>

<p>In XbyK, you can use the same T-SQL syntax in the <code>string[]</code> overload of the <code>OrderBy</code> extension method for <code>RetrievePagesQueryParameters</code>.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
var parameters = new RetrievePagesParameters
{
    // Specify the language version to look for
    LanguageName = "en-US", 
    // Ensure the latest edited version of pages under workflow
    IsForPreview = true, 
    // Specify which channel to query pages from
    ChannelName = "DancingGoatCore" 
};

// Retrieve brewers
var brewers = await contentRetriever.RetrievePages&lt;Brewer&gt;( 
    parameters: parameters,
    additionalQueryConfiguration: query =&gt; query
        // Define a custom sorting order
        .OrderBy("CASE WHEN ContentItemName LIKE 'Hario%' THEN 0 ELSE 1 END, ContentItemName"), 
    cacheSettings: RetrievalCacheSettings.CacheDisabled
);
</code></pre>
</div>

<h2 id="use-a-subquery">Use a subquery</h2>
<p>In the previous example, we retrieved items based on a provided collection of IDs. This time, let’s cover a similar scenario, but we’ll dynamically resolve that list based on another query.</p>
<p>Here is the KX13 code, inspired by a support case, which searches for <em>Twitter post</em> objects referencing articles that are not published:</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>KX13</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
// Retrieve twitter posts
var posts = TwitterPostInfoProvider.GetTwitterPostInfoByAccountId(twitterAccount.TwitterAccountID) 
    // Find posts that are not yet published to Twitter
    .Where(tp =&gt; !tp.IsPublished) 
    // Only retrieve posts that reference pages from the subquery
    .WhereIn("TwitterPostDocumentGUID", DocumentHelper
        // Retrieve articles
        .GetDocuments("DancingGoatCore.Article")
            // Specify the ID column used to filter the parent query
            .Column("DocumentGUID")
            // Specify the culture (language) version to look for
            .Culture("en-us") 
            // Specify which site to query pages from
            .OnSite("DancingGoatCore")) 
    // Order by date scheduled for publishing
    .OrderBy(tp =&gt; tp.TwitterPostScheduledPublishDateTime) 
    // Execute query to get results in enumerable format
    .ToList(); 
</code></pre>
</div>

<p>Moving on to XbyK, there is no built-in Twitter feature. Let’s imagine we’ve recreated this functionality using the Content hub, with a <code>SocialMediaPush</code> content type. Now, we promote content from <code>SocialMediaPush</code> items to multiple social media platforms via a third-party service, instead of just posting to Twitter.</p>
<p>The third-party publishing service posts to a custom endpoint after a successful push to all platforms, which then updates <code>SocialMediaPushIsPublished</code> to <code>true</code>.</p>
<p>The resulting XbyK query uses the same <code>IContentRetriever</code> object to make two queries:</p>
<ul>
<li>One retrieves reusable items from the Content hub using <code>RetrieveContentParameters</code>.</li>
<li>The other retrieves articles from a website channel using <code>RetrievePagesParameters</code>.</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
var parameters = new RetrieveContentParameters
{
    // Specify the language version to look for
    LanguageName = "en-US",
    // Include non-published content items
    IsForPreview = true,
};

var subQueryParameters = new RetrievePagesParameters
{
    // Specify the language version to look for
    LanguageName = "en-US",
    // Specify which channel to query pages from
    ChannelName = "DancingGoatCore",
    // Include non-published content items
    IsForPreview = true,
};

// Subquery
var articles = await contentRetriever
    // Retrieve articles
    .RetrievePages&lt;Article&gt;(
        parameters: subQueryParameters,
        additionalQueryConfiguration: subQuery =&gt; subQuery
            // Specify the ID column used to filter the parent query
            .Columns(nameof(Article.SystemFields.ContentItemID)),
        cacheSettings: RetrievalCacheSettings.CacheDisabled);

// Primary query
var posts = await contentRetriever.RetrieveContent&lt;SocialMediaPush&gt;(
        parameters: parameters,
        additionalQueryConfiguration: query =&gt; query
            // Find posts that are not yet published to social media
            .Where(where =&gt; where.WhereFalse(nameof(SocialMediaPush.SocialMediaPushIsPublished)))
            // Only retrieve posts that reference pages from the articles subquery
            .Linking(nameof(SocialMediaPush.SocialMediaPushPage), articles.Select(article =&gt; article.SystemFields.ContentItemID))
            // Order by date scheduled for publishing
            .OrderBy(nameof(SocialMediaPush.SocialMediaPushScheduledPublishDateTime)),
        cacheSettings: RetrievalCacheSettings.CacheDisabled
    );
</code></pre>
</div>


<div>

</div>
<div>
<p>We’ve broken the query, subquery, and parameters for each into separate blocks for readability, but they are nestable if your code style conventions prefer to avoid this kind of separation.</p>
</div>

<h2 id="upgrade-a-repository">Upgrade a repository</h2>
<p>For our last example, let’s look at something more reusable, using methods from the <code>BasePageRepository</code> in the Kentico Xperience 13 <a href="https://github.com/Kentico/xperience-training-13/blob/master/XperienceAdapter/Repositories/BasePageRepository.cs" target="_blank">training site</a>.</p>
<p>This sample contains two methods:</p>
<ul>
<li>
<code>GetPagesInCurrentCultureAsync</code>, which retrieves pages in the provided culture, allowing for configuration through functions and mappers</li>
<li>
<code>GetAllAsync</code>, which utilizes <code>GetPagesInCurrentCultureAsync</code> to retrieve all pages of the repository’s specified type</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>KX13</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
public virtual async Task&lt;IEnumerable&lt;TPageDto&gt;&gt; GetAllAsync(CancellationToken? cancellationToken = default) =&gt;
    await GetPagesInCurrentCultureAsync(
        cancellationToken,
        buildCacheAction: cache =&gt; cache
            // Set cache key
            .Key($"{nameof(BasePageRepository&lt;TPageDto, TPage&gt;)}|{typeof(TPage).Name}") 
            // Set cache expiration to 30 seconds
            .Expiration(TimeSpan.FromSeconds(30))); 

public virtual async Task&lt;IEnumerable&lt;TPageDto&gt;&gt; GetPagesInCurrentCultureAsync(
    CancellationToken? cancellationToken = default,
    Action&lt;DocumentQuery&lt;TPage&gt;&gt;? filter = default,
    Func&lt;TPage, TPageDto, TPageDto&gt;? additionalMapper = default,
    Action&lt;IPageCacheBuilder&lt;TPage&gt;&gt;? buildCacheAction = default,
    bool includeAttachments = default)
{
    //Current culture and site are used by default with IPageRetriever
    var result = await _repositoryServices.PageRetriever.RetrieveAsync(query =&gt;
    {
        // Filter columns
        query.Columns(DefaultDtoFactory().SourceColumns); 
        // Apply additional filtering if provided
        filter?.Invoke(query); 
    },
    buildCacheAction,
    cancellationToken);

    return MapPages(result, additionalMapper, includeAttachments);
}
</code></pre>
</div>

<p>Since these KX13 methods use <code>IPageRetriever</code>, converting them to use <code>IContentRetriever</code> is a bit more straightforward.</p>
<p>However, there are still some notable changes, such as:</p>
<ul>
<li>The format of cache settings, now a <code>RetrievalCacheSettings</code> object instead of an <code>Action</code>
</li>
<li>The definition of the cache item’s suffix, rather than its entire name</li>
<li>The use of a separate parameters object</li>
<li>The replacement of <a href="/13/managing-website-content/working-with-files/page-attachments">page attachments</a> with reusable content items</li>
<li>The existence of a linked items depth parameter in Xperience by Kentico</li>
</ul>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>XbyK</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
public virtual async Task&lt;IEnumerable&lt;TPageDto&gt;&gt; GetAllAsync(CancellationToken? cancellationToken = default) =&gt;
    await GetPagesInCurrentCultureAsync(
        cancellationToken,
        cacheSettings: new RetrievalCacheSettings(
            // Set cache key suffix
            cacheItemNameSuffix: $"{nameof(BasePageRepository&lt;TPageDto, TPage&gt;)}|{typeof(TPage).Name}", 
            // Set cache expiration to 30 seconds
            cacheExpiration: TimeSpan.FromSeconds(30), 
            useSlidingExpiration: true,
            additionalCacheDependencies: null
        )
    );

public virtual async Task&lt;IEnumerable&lt;TPageDto&gt;&gt; GetPagesInCurrentCultureAsync(
    CancellationToken? cancellationToken = default,
    Action&lt;RetrievePagesQueryParameters&gt;? filter = null,
    Func&lt;TPage, TPageDto, TPageDto&gt;? additionalMapper = default,
    RetrievalCacheSettings? cacheSettings = default,
    int depth = 1)
{
    // Current culture and channel are used by default in IContentRetriever
    var result = await contentRetriever.RetrievePages&lt;TPage&gt;(
        parameters: new RetrievePagesParameters
        {
            // Set the depth of linked items to retrieve
            LinkedItemsMaxLevel = depth 
        },
        additionalQueryConfiguration: query =&gt;
        {
            // Apply additional filtering if provided (queryConfiguration)
            filter?.Invoke(query); 
            // Filter columns
            query.Columns(DefaultDtoFactory().SourceColumns); 
        },
        cacheSettings: cacheSettings ?? RetrievalCacheSettings.CacheDisabled);

    return MapPages(result, additionalMapper, depth);
}
</code></pre>
</div>


<div>

</div>
<div>
<p><strong>MapPages method</strong></p>
<p>The <code>MapPages</code> method, which converts a <code>TPage</code> object into a <code>TPageDto</code> object, is beyond the scope of this example.</p>
<p>Because the migration tool converts attached files to reusable content items, we assume the new <code>MapPages</code> implementation uses the <code>depth</code> parameter to decide whether it should work with related files, instead of the <code>includeAttachments</code> boolean parameter.</p>
</div>

<h2 id="whats-next">What’s next?</h2>
<p>If you haven’t already, we recommend checking out our <a href="/guides/architecture/upgrade-from-kx13/upgrade-walkthrough">upgrade walkthrough</a>, to see content retrieval migration in context of the whole upgrade process, including more caching examples. You can find more advanced upgrade and data migration use cases in our other <a href="/guides/development/upgrade-deep-dives">Upgrade deep dive guides</a>.</p>
<p>If you’ve encountered any pain points during your upgrade to Xperience by Kentico that additional training materials could help with, or you’ve found any issues in our existing materials, please use the <strong>Send us feedback</strong> button at the bottom of the page to let us know!</p>

</body>
</html>
