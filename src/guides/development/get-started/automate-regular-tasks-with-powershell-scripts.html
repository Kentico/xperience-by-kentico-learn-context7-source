<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Automate regular tasks with PowerShell scripts</title>
</head>
<body>
<p>Many development teams use PowerShell scripts to speed up common tasks. Even in cases where the script automates one or two commands, a developer can simply run a file from a folder without the need to look up or memorize several specific commands.</p>
<p>This guide will show you how to create PowerShell scripts to automate common recurring tasks in Kentico Xperience environments.</p>

<div>

</div>
<div>
<p><strong>Repository and folder structure</strong></p>
<p>The examples in this guide use the structure of the <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/tree/finished" target="_blank">training guides repository</a> when traversing directories.</p>
<p>Each script will assume it is located in a folder called <em>scripts</em> in the root of the repository, and will deal with projects located in the <em>src</em> folder.</p>
</div>


<div>

</div>
<div>
<p>The code samples in this guide were developed using Windows PowerShell 5.1. Note that some other versions of PowerShell may not support the same commands, and you may need to make minor adjustments for your environment.</p>
</div>

<h2 id="generate-code-files">Generate code files</h2>
<p>Code generation is a common development function that requires a command. Xperience code generation through the .NET CLI automatically generates strongly typed C# classes and interfaces based on content types, module classes, reusable field schemas and forms that exist in the Xperience database.</p>
<p>The code generation command has <a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects#generate-code-files">many parameters</a> that you can use to control which objects to include and where to save their files.</p>
<p>This guide’s example will demonstrate all object types and save them to the <em>TrainingGuides.Entities</em> project.</p>
<ol type="1">
<li>
<p>Save the current location to a variable before switching to the <em>TrainingGuides.Web</em> directory.</p>

<div>

</div>
<div>
Utilize the PowerShell <a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_automatic_variables?view=powershell-7.4#psscriptroot" target="_blank">$PSScriptRoot</a> variable to ensure the correct file paths even if you call the script from other than the <em>scripts</em> folder.
</div>
</li>
<li><p>Call the <code>run</code> command in the .NET CLI with the <code>--kxp-codegen</code> option and specify the <code>--type</code> parameter for each type supported by the tool.</p></li>
<li>
<p>Return back to the initial directory, in case the script is called through a command window instead of with a click.</p>

<div>

</div>
<div>
This way developers executing the script through the command line can continue their work without having to change directories.
</div>
</li>
<li><p>Track errors and use that to determine whether the script returns a nonzero exit code. You can extract this into a function and add some human-friendly messages.</p></li>
</ol>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>GenerateCodeFiles.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Generates code for classes, forms, and content types stored in the database.
#&gt;
$exitCode = 0

$originalLocation = Get-Location
Set-Location -Path $PSScriptRoot/../src/TrainingGuides.Web

# https://docs.xperience.io/xp/developers-and-admins/development/content-retrieval/generate-code-files-for-xperience-objects

$contentTypesNamespace = "TrainingGuides"

function Write-Result-Get-Exit-Code {
    param(
        [string] $type
    )    
    if ($LASTEXITCODE -ne 0) {
        Write-Error "$type code generation failed."
        return 1;
    }
    else{
        Write-Host "$type code generation succeeded." -ForegroundColor Green
        return 0;
    }
    Write-Host
}

#Reusable content types
dotnet run --no-build -- --kxp-codegen --type "ReusableContentTypes" --namespace $contentTypesNamespace --location "../TrainingGuides.Entities/{type}/{name}"
$exitCode = Write-Result-Get-Exit-Code "Reusable content type"

#Page content types
dotnet run --no-build -- --kxp-codegen --type "PageContentTypes" --namespace $contentTypesNamespace --location "../TrainingGuides.Entities/{type}/{name}" --skip-confirmation
$exitCode = Write-Result-Get-Exit-Code "Page content type"

#Reusable field schemas
dotnet run --no-build -- --kxp-codegen --type "ReusableFieldSchemas" --namespace $contentTypesNamespace --location "../TrainingGuides.Entities/{type}/{name}" --skip-confirmation
$exitCode = Write-Result-Get-Exit-Code "Reusable field schema"

#Custom module classes
dotnet run --no-build -- --kxp-codegen --type "Classes" --with-provider-class False --location "../TrainingGuides.Entities/{type}/{name}" --skip-confirmation
$exitCode = Write-Result-Get-Exit-Code "Class"

#Forms
dotnet run --no-build -- --kxp-codegen --type "Forms" --location "../TrainingGuides.Entities/{type}/{name}" --skip-confirmation
$exitCode = Write-Result-Get-Exit-Code "Form"

if ($exitCode -ne 0) {
    Set-Location -Path $originalLocation
    Write-Error "Completed with errors. See above."
    Read-Host -Prompt "Press Enter to exit"
    exit $exitCode
}

Set-Location -Path $originalLocation
Read-Host -Prompt "Press Enter to exit"
</code></pre>
</div>


<div>

</div>
<div>
Visit our <a href="/documentation/developers-and-admins/api/generate-code-files-for-system-objects">Code generator documentation</a> to learn more about its parameters and usage. Additionally, you can see a more detailed exploration and examples <a href="/guides/development/get-started/generate-code-for-custom-content-and-data-classes">in this video</a>.
</div>

<h2 id="publish">Publish</h2>
<p>The .NET CLI allows for projects to be built and published, meaning this process can be automated. Using a Powershell script, you can carry out additional automated steps before and after, and ensure your team doesn’t need to worry about Visual Studio <em>publish</em> <em>profiles</em>.</p>
<p>This example is relatively straightforward, but you can expand it with additional deployment tasks for your specific scenario.</p>
<ol type="1">
<li>Take a <code>switch</code> parameter called <code>$KeepProductVersion</code> to represent whether or not a custom build number should be used as the version suffix.</li>
<li>Save the current location and set up variables to store the path to the output folder and the build number.</li>
<li>Switch to the <em>TrainingGuides.Web</em> directory.</li>
<li>Assemble a new string containing the <code>dotnet publish</code> command based on the value of the <code>$KeepProductVersion</code> parameter, and execute it.</li>
<li>Log any errors before returning to the original directory, in case the script is called through a command window instead of by clicking.</li>
</ol>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>Publish.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Creates a deployment package.
#&gt;
    [CmdletBinding()]
param ([switch]$KeepProductVersion)

$originalLocation = Get-Location
Set-Location -Path $PSScriptRoot

$outputFolderPath = "./bin/Deployment/"
$buildNumber = (Get-Date).ToUniversalTime().ToString("yyyyMMddHHmm")

Set-Location -Path ../src/TrainingGuides.Web

# Publish the application in the 'Release' mode
$publishCommand = "dotnet publish --nologo -c Release --self-contained true --runtime win-x64 -o $OutputFolderPath"

if (!$KeepProductVersion) {
    $publishCommand += " --version-suffix $buildNumber"
}

Write-Host $publishCommand

Invoke-Expression $publishCommand

if ($LASTEXITCODE -ne 0) {
    Set-Location -Path $originalLocation
    Write-Error "Publishing the website failed."
    Read-Host -Prompt "Press Enter to exit"
    exit 1
}

Set-Location -Path $originalLocation
Read-Host -Prompt "Press Enter to exit"

</code></pre>
</div>

<h2 id="continuous-integration">Continuous integration</h2>

<div>

</div>
<div>
<p><em><a href="/documentation/developers-and-admins/ci-cd/continuous-integration">Continuous integration</a> (CI)</em> is a feature of Xperience that allows you to easily share database changes with other developers on your team.</p>
<p>Using the <code>--kxp-ci-store</code> option you can serialize your data changes into XML format in your file system (see <a href="#ci-store">CI store</a>). These can be shared over a source control with your team members who can then restore the changes to update their database, using <code>--kxp-ci-restore</code> (see <a href="#ci-restore">CI restore</a>).</p>
<p>The following sections will share tips and best practices on how to work with these commands to help your team be the most effective.  </p>
</div>

<h3 id="ci-store">CI store</h3>
<p>The following script serializes database data and automatically stores it in the <em>App_Data/CIRepository</em>directory of your current project - in this case, the <em>TrainingGuides.Web</em>.</p>
<ol type="1">
<li>Save the current location to a variable, and switch to the <em>TrainingGuides.Web</em> directory.</li>
<li>Call the <code>run</code> command in the .NET CLI with the <code>--kxp-ci-store</code> option.
<ul>
<li>Optionally, use the <code>--no-build</code> parameter to save time, if your team knows to run the command only when the site has been compiled with any necessary updates.</li>
</ul>
</li>
<li>Log an error if there are any issues.</li>
<li>Return to the original directory, in case it is being run from a PowerShell window instead of with a click.</li>
</ol>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>CIStore.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Serializes database data to the continuous integration repository.
#&gt;

$originalLocation = Get-Location
Set-Location -Path $PSScriptRoot/../src/TrainingGuides.Web

Write-Host 'Storing CI files'

dotnet run --no-build --kxp-ci-store

if ($LASTEXITCODE -ne 0) {
    Set-Location -Path $originalLocation
    Write-Error "CI store failed."
    Read-Host -Prompt "Press Enter to exit"
    exit 1
}
else{
    Write-Host 'CI files stored'
}

Set-Location -Path $originalLocation

Read-Host -Prompt "Press Enter to exit"

</code></pre>
</div>

<h3 id="connection-string-function">Connection string function</h3>
<p>Restoring data from the <em>CIRepository</em> requires retrieving a connection string to access the database. Because there are two more scripts in this guide that will need this utility, let’s create a reusable <em>Get-ConnectionString</em> script before diving into <a href="#ci-restore">CI restore</a>.</p>
<ol type="1">
<li><p>Create a new file called <em>Get-ConnectionString.ps1</em> in the <em>scripts</em> directory of the repository.</p></li>
<li><p>Define a function with the same name as the file, taking two <code>string</code> parameters: <code>$Path</code> and <code>$OriginalLocation</code>.</p></li>
<li>
<p>Check if there is a <em>CMSConnectionString</em> saved in the user secrets, and return it if found.</p>

<div>
Leave this part out if your team does not use user secrets.<br>

</div>
</li>
<li><p>Fall back the <em>appSettings.json</em> file for the <em>CMSConnectionString</em> if one is not found in the user secrets.</p></li>
</ol>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>Get-ConnectionString.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Contains functions for use in other scripts
#&gt;

&lt;#
.DESCRIPTION
   Gets the database connection string from the config file
#&gt;
function Get-ConnectionString {
    param(
        [string] $Path,
        [string] $OriginalLocation
    )

    # Try to get the connection string from user secrets first
    $connectionString = dotnet user-secrets list --project $Path `
        | Select-String -Pattern "ConnectionStrings:" `
        | ForEach-Object { $_.Line -replace '^ConnectionStrings:CMSConnectionString \= ','' }        

    if (-not [string]::IsNullOrEmpty($connectionString)) {
        Write-Host 'Using ConnectionString from user-secrets'

        return $connectionString
    }

    Write-Host 'Unable to find connection string in user secrets.'

    $appSettingsFileNames = 'appSettings.json'
    
    foreach ($appSettingFileName in $appSettingsFileNames)
    {
        $jsonFilePath = Join-Path $Path $appSettingFileName
        
        if (Test-Path $jsonFilePath)
        {
            $appSettingsJson = Get-Content $jsonFilePath | Out-String | ConvertFrom-Json
            $connectionString = $appSettingsJson.ConnectionStrings.CMSConnectionString;
            
            if ($connectionString)
            {
                Write-Host "Using ConnectionString from $appSettingFileName"

                return $connectionString;
            }
        }
    }    

    Set-Location $OriginalLocation
    Write-Error "Connection string not found."
    Read-Host -Prompt "Press Enter to exit"
    exit 1
}
</code></pre>
</div>

<h3 id="ci-restore">CI restore</h3>
<p>The script below covers restoring data from the <em>App_Data/CIRepository</em> folder of your project and updating the Xperience database to match the version specified by the NuGet packages in your application.</p>
<p>While it may take just a single command to restore objects from the <em>CIRepository</em> to the database, things get more complicated when changes are made to the database structure.</p>
<p>Continuous integration handles some database schema changes on its own, creating and deleting tables for custom content types, forms, and module classes. However, further customizations, such as custom indexes, are not accounted for.</p>
<p><a href="/documentation/developers-and-admins/ci-cd/ci-cd-database-migration-scripts">Our documentation</a> shows how to run migration scripts before and after a CI restore. Since certain changes to the database schema may interfere with the restore process, this process automatically executes certain SQL commands before and after the CI restore operation.</p>
<p>This guide’s example closely follows the PowerShell script provided by the documentation. Start by copying the script and changing it in three key ways.</p>
<ul>
<li>Assume that the script is stored in the <em>scripts</em> folder of the repository, and remove the path as a parameter.</li>
<li>Use the <code>Get-ConnectionString</code> function from the <a href="#connection-string-function">previous section</a>, rather than including the function innately.</li>
<li>Add a <code>Handle-Error</code> function that sets location back to the original directory, logs an error and returns <code>exit 1</code>. Use it throughout the script.</li>
</ul>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>CIRestore.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Restores objects serialized in the CI repository into the database.
#&gt;
param (
    # Displays time elapsed for the restore operation including migrations
    [switch] $DisplayTimeElapsed
)

$originalLocation = Get-Location
Set-Location -Path $PSScriptRoot

. .\Get-ConnectionString.ps1

$beforeList = "Before.txt"
$afterList = "After.txt"
$repositoryPath = "App_data\CIRepository"
$migrationFolder = "@migrations"

Set-Location -Path ../src/TrainingGuides.Web

$path = Get-Location

&lt;#
.DESCRIPTION
   Handles errors by displaying a message and exiting the script.
#&gt;
function Handle-Error {
    param(
        [string] $Message
    )
    Set-Location -Path $originalLocation
    Write-Error $Message
    Read-Host -Prompt "Press Enter to exit"
    exit 1
}

&lt;#
.DESCRIPTION
   Runs a database migration with the given name
#&gt;
function Run-Migration {
    param(
        [System.Data.SqlClient.SqlConnection] $Connection,
        [System.Data.SqlClient.SqlTransaction] $Transaction,
        [string] $MigrationName
    )
    
    $migrationPath = "$path\$repositoryPath\$migrationFolder\$MigrationName.sql"
    if (!(Test-Path $migrationPath)) {
        Write-Error "The file $migrationPath does not exist."
        return $FALSE
    }
    
    $sourceScript = Get-Content $migrationPath

    $sqlCommand = ""
    $sqlList = @()

    foreach ($line in $sourceScript) { 
        if ($line -imatch "^\s*GO\s*$") { 
            $sqlList += $sqlCommand
            $sqlCommand = ""
        }
        else {           
            $sqlCommand += $line + "`r`n" 
        }
    }
    
    $sqlList += $sqlCommand

    $rowsAffected = 0
    foreach ($sql in $sqlList) {
        if ([bool]$sql.Trim()) {
            $command = New-Object System.Data.SqlClient.SqlCommand($sql, $Connection)
            $command.Transaction = $Transaction

            try {
                $rowsAffectedInBatch = $command.ExecuteNonQuery()

                if ($rowsAffectedInBatch -gt 0) {
                    $rowsAffected += $rowsAffectedInBatch
                }
            }
            catch {
                Write-Error $_.Exception.Message                    
                return $FALSE
            }
        }
    }

    Log-RowsAffected -Connection $Connection -Transaction $Transaction -MigrationName $MigrationName -RowsAffected $rowsAffected

    return $TRUE
}


&lt;#
.DESCRIPTION
   Logs rows affected by the migration.
#&gt;
function Log-RowsAffected {
    param(
        [System.Data.SqlClient.SqlConnection] $Connection,
        [System.Data.SqlClient.SqlTransaction] $Transaction,
        [string] $MigrationName,
        [int] $RowsAffected
    )

    $logRowsAffectedQuery = "UPDATE CI_Migration SET RowsAffected = $RowsAffected WHERE MigrationName = '$MigrationName'"
    $logRowsAffectedCommand = New-Object System.Data.SqlClient.SqlCommand($logRowsAffectedQuery, $Connection)
    $logRowsAffectedCommand.Transaction = $Transaction

    try {
        $logRowsAffectedCommand.ExecuteNonQuery()
    }
    catch {
        Write-Host "Can't log rows affected: $_.Exception.Message"
    }
}

&lt;#
.DESCRIPTION
   Checks if a migration with the given name was already applied. If not, the method returns false and the migration is marked as applied.
#&gt;
function Check-Migration {
    param(
        [System.data.SqlClient.SQLConnection] $Connection,
        [System.Data.SqlClient.SqlTransaction] $Transaction,
        [string] $MigrationName
    )

    $sql = "DECLARE @migrate INT
            EXEC @migrate = Proc_CI_CheckMigration '$MigrationName'
            SELECT @migrate"

    $command = New-Object system.data.sqlclient.sqlcommand($sql, $Connection)
    $command.Transaction = $Transaction

    return $command.ExecuteScalar()
}


&lt;#
.DESCRIPTION
   Runs all migrations in the migration list
#&gt;
function Run-MigrationList {
    param(
        [string] $ConnectionString,
        [string] $MigrationList
    )

    $migrations = Get-Content "$path\$repositoryPath\$MigrationList"

    $connection = New-Object system.data.SqlClient.SQLConnection($ConnectionString)
    $connection.Open()
    foreach ($migrationName in $migrations) {
        $transaction = $connection.BeginTransaction("MigrationTransaction")

        if (Check-Migration -Connection $connection -Transaction $transaction -MigrationName $migrationName) {
            Write-Host "Applying migration '$migrationName'."
            if (!(Run-Migration -Connection $Connection -Transaction $transaction -MigrationName $migrationName)) {
                $transaction.Rollback()
                $connection.Close()
                return $FALSE
            }
        }

        $transaction.Commit()
    }

    $connection.Close()

    return $TRUE
}


&lt;#
.DESCRIPTION
   Restores the repository to the database and executes migrations before and after the restore.
#&gt;
function Run-Restore {
    param(
        [string] $Path
    )
    
    $connectionString = Get-ConnectionString -Path $Path -OriginalLocation $originalLocation
    
    # Creates an 'App_Offline.htm' file to stop the website
    "&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;Continuous Integration restore in progress...&lt;/body&gt;&lt;/html&gt;" &gt; "$Path\App_Offline.htm"

    # Executes migration scripts before the restore
    if (!(Run-MigrationList $connectionString $beforeList)) {
        Handle-Error "Database migrations before the restore failed."
    }
    
    $configuration = "Release";
    if (Test-Path (Join-Path $Path "bin\Debug"))
    {
        $configuration = "Debug"; 
    }

    # Runs the restore CLI command
    dotnet run --project $Path --no-build -c "$configuration" -- --kxp-ci-restore
    if ($LASTEXITCODE -ne 0) {
        Handle-Error "Restore failed."
    }

    # Executes migration scripts after the restore
    if (!(Run-MigrationList $connectionString $afterList)) {
        Handle-Error "Database migrations after the restore failed."
    }

    # Removes the 'App_Offline.htm' file to bring the site back online
    Remove-Item "$Path\App_Offline.htm"   

    Write-Host "Done"
}

$sw = [System.Diagnostics.Stopwatch]::StartNew()

Run-Restore -Path $path

$sw.Stop()
if ($DisplayTimeElapsed) {
    Write-Host "Time Elapsed: $($sw.Elapsed)"
}

if ($LASTEXITCODE -ne 0) {
    Handle-Error "Completed with errors. See above."
}

Set-Location -Path $originalLocation

Read-Host -Prompt "Press Enter to exit"

</code></pre>
</div>

<p>While most of the script is copied from the documentation, it is still worth understanding its primary components, and the structures it relies on.</p>
<p>Essentially, the script needs the <em>App_Data/CIRepository</em> folder to contain files called <em>Before.txt</em> and <em>After.txt</em>. These text files can hold lists of the names of <em>.sql</em> files in the <em>@migrations</em> subfolder (not including the extension). The lists in the text files determine which of these SQL files, called <em>migrations,</em> are executed, and in what order.</p>
<p>Information about the migrations is logged into the <code>CI_Migration</code> table of the database, which you can check to ensure that the same migration does not run multiple times.</p>
<ul>
<li>
<code>Run-Migration</code>
<ul>
<li>Finds the SQL file that corresponds to the provided migration name and executes the commands within it, using the provided connection and transaction.</li>
<li>Returns <code>$FALSE</code> if it throws an exception, <code>$TRUE</code> otherwise.</li>
<li>Is called by <code>Run-MigrationList.</code>
</li>
</ul>
</li>
<li>
<code>Log-RowsAffected</code>
<ul>
<li>Logs how many rows were affected by a migration to the row corresponding to it in the <code>CI_Migration</code> table of the database.</li>
<li>Is called by <code>Run-Migration.</code>
</li>
</ul>
</li>
<li>
<code>Check-Migration</code>
<ul>
<li>Checks the <code>CI_Migration</code> table to see if a migration with the given name was already applied.</li>
<li>Returns <code>$TRUE</code> if the migration already exists, <code>$FALSE</code> otherwise.</li>
<li>Is called by <code>Run-MigrationList.</code>
</li>
</ul>
</li>
<li>
<code>Run-MigrationList</code>
<ul>
<li>Establishes a database connection, then creates and executes a new transaction for each migration name in the provided list.</li>
<li>Commits the transactions after they are executed.</li>
<li>Rolls back transaction and returns <code>$FALSE</code> if an exception is encountered, returns <code>$TRUE</code> otherwise.</li>
<li>Is called by <code>Run-Restore.</code>
</li>
</ul>
</li>
<li>
<code>Run-Restore</code>
<ul>
<li><p>Takes the application offline and runs the <em>Before</em> migration list.</p></li>
<li>
<p>Runs a CI restore.</p>

<div>

</div>
<div>
Just like the <a href="#ci-store">CI store script above</a>, CI restore also uses the optional <code>--no-build</code> parameter. Consider your team’s procedures when deciding whether to include it.
</div>
</li>
<li><p>Runs the <em>After</em> migration list and brings the application back online.</p></li>
<li><p>Writes any errors it encounters along the way.</p></li>
</ul>
</li>
</ul>
<p>To provide this script with the conditions it needs, create new text files named <em>Before.txt</em> and <em>After.txt</em> in the <em>App_Data/CIRepository</em> folder of the <em>TrainingGuides.Web</em> project, along with an empty folder named <em>@migrations</em>.</p>

<div>

</div>
<div>
You can find an example of the type of migration that can be run here on <a href="/documentation/developers-and-admins/ci-cd/ci-cd-database-migration-scripts#example---database-change-migration-script">this documentation page</a>.
</div>

<h2 id="update">Update</h2>
<p>The last script updates the Xperience by Kentico instance to the version specified by the application’s NuGet packages.</p>
<p>To prevent continuous integration operations from interfering and causing errors, the script needs to disable CI before running the update. After the update is finished it will re-enable CI.</p>
<p>Since continuous integration is enabled and disabled through a settings key, a database connection is necessary to change these settings.</p>
<ol type="1">
<li>Dot-source the <em>Get-ConnectionString.ps1</em> script, to re-use the <code>Get-ConnectionString</code> function.</li>
<li>Add a <code>Handle-Error</code> function that sets location back to the original directory, logs an error and returns <code>exit 1</code>. Use it throughout the script.</li>
<li>Create a function, <code>Execute-SQL-Command</code> to execute a SQL command that does not return a dataset.
<ul>
<li>This is used later on to set the value of the settings key.</li>
</ul>
</li>
<li>Add another function, <code>Execute-SQL-Data-Query</code> to execute an SQL query that returns a dataset.
<ul>
<li>This is used later on to check the current value of the settings key.</li>
</ul>
</li>
<li>Switch to the <em>TrainingGuides.Web</em> directory and retrieve the current connection string.</li>
<li>Call the <code>Execute-SQL-Data-Query</code> function to check whether continuous integration is in use and save the return value to a variable for future reference.</li>
<li>If CI is enabled, disable it using the <code>Execute-SQL-Data-Query</code> function.</li>
<li>Call the <code>run</code> command in the .NET CLI and use the <code>--kxp-update</code> option to trigger the update, log an error if any issues are encountered.</li>
<li>If CI was initially enabled, re-enable it, so that the serialized objects will reflect any new database structure.</li>
<li>Attempt to serialize all objects with the <em>CI store</em> operation, returning an error if it fails.</li>
<li>Return to the original directory, in case the script is being run from a PowerShell window instead of with a click.</li>
</ol>

<div>
<div>
<div>
<span>PS</span>
</div>
<strong>Update-XperienceDatabaseOnly.ps1</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
&lt;#
.Synopsis
    Updates Xperience by Kentico to the version specified by the installed NuGet packages.
#&gt;

$originalLocation = Get-Location
Set-Location -Path $PSScriptRoot

. .\Get-ConnectionString.ps1

function Handle-Error {
    param(
        [string] $Message
    )
    Set-Location -Path $originalLocation
    Write-Error $Message
    Read-Host -Prompt "Press Enter to exit"
    exit 1
}

#Query that executes a command without returning a dataset.
function Execute-SQL-Command {
    param(
        [string] $ConnectionString,
        [string] $CommandText
    )
    $connection = New-Object system.data.SqlClient.SQLConnection($ConnectionString)

    $connection.Open()
    $command = new-object system.data.sqlclient.sqlcommand($CommandText,$connection)
    $transaction = $connection.BeginTransaction()
    $command.Transaction = $transaction

    try {
        $rowsAffected = $command.ExecuteNonQuery()
        Write-Host 'Command: '$CommandText
        Write-Host 'Rows affected: '$rowsAffected
        $transaction.Commit()
    }
    catch {
        Write-Error $_.Exception.Message
        return $FALSE
    }    

    $connection.Close()

    return $TRUE
}

#Query that retrieves a data set
function Execute-SQL-Data-Query {
    param(
        [string] $ConnectionString,
        [string] $CommandText
    )
    $connection = New-Object System.Data.SqlClient.SQLConnection($ConnectionString)

    $connection.Open()

    $command = New-Object System.Data.SqlClient.SqlCommand($CommandText,$connection)
    $dataAdapter = New-Object System.Data.SqlClient.SqlDataAdapter($command)
    $dataset = new-object System.Data.Dataset
    $dataAdapter.Fill($dataset)

    $connection.Close()

    return $dataset
}

Set-Location -Path ..\src\TrainingGuides.Web

$appPath = Get-Location

$connectionString = Get-ConnectionString -Path $appPath -OriginalLocation $originalLocation

$resultDataSet = Execute-SQL-Data-Query -ConnectionString $connectionString -CommandText "SELECT KeyValue FROM CMS_SettingsKey WHERE KeyName = N'CMSEnableCI'"

$isUsingCD = $resultDataSet.Tables[0].Rows[0][0]

$readyToUpdate = $True

#Since the settings key value is a string and could theoretically be something other than true or false, compare the value rather than treating it as a boolean expression on its own
if($isUsingCD -eq 'True'){
    Write-Host 'Disabling continuous integration'
    $commandResult = Execute-SQL-Command -ConnectionString $connectionString -CommandText "UPDATE CMS_SettingsKey SET KeyValue = N'False' WHERE KeyName = N'CMSEnableCI'"
    $readyToUpdate = $commandResult
}

if($readyToUpdate){
    Write-Host 'Starting Xperience update'

    dotnet run --no-build --kxp-update

    if ($LASTEXITCODE -ne 0) {
        Handle-Error "Update failed."
    }
}
else{
    Handle-Error 'Unable to disable continuous integration to perform the update.'
}

if($isUsingCD -eq 'True'){
    Write-Host 'Re-enabling continuous integration'

    $commandResult = Execute-SQL-Command -ConnectionString $connectionString -CommandText "UPDATE CMS_SettingsKey SET KeyValue = N'True' WHERE KeyName = N'CMSEnableCI'"    
    
    if(-not $commandResult){
        Handle-Error 'Unable to re-enable continuous integration.'
    }

    dotnet run --kxp-ci-store

    if($LASTEXITCODE -ne 0) {
        Handle-Error 'Unable to store continuous integration. Make sure to run the store operation after fixing any issues.'
    }
}

Set-Location -Path $originalLocation

Read-Host -Prompt "Press Enter to exit"

</code></pre>
</div>


<div>

</div>
<div>
<p><strong>Refactoring</strong></p>
<p>You may have noticed the <em>Update-XperienceDatabaseOnly</em> script file contains two function definitions: <code>Execute-SQL-Command</code> and <code>Execute-SQL-Data-Query.</code> If you have use for these functions elsewhere, consider extracting them into separate files and re-using them, as you did <code>Get-ConnectionString</code> earlier.</p>
<div>
<div>

</div>
<div>
<p><strong>SQL transactions</strong></p>
<p>Note that unlike the SQL functionality in the <em>RestoreCI</em> script, the functions in the <em>Update-XperienceDatabaseOnly</em> script close the connection immediately, rather than executing several transactions on one connection.</p>
<p>This ensures no connections are left open during the update, but may be less efficient if these functions were repurposed to process several consecutive commands.</p>
</div>
</div>
</div>


<div>

</div>
<div>
<p><strong>Data consistency</strong></p>
<p>If the <em>CI store</em> operation fails when you run this script, we highly recommend taking the following steps after addressing the issue that led to failure:</p>
<ol type="1">
<li>Building your application</li>
<li>Running <a href="#ci-store">CI store</a>
</li>
</ol>
<p>This ensures that updates to the schema of objects in the database are not in conflict with the data serialized in the CI repository.</p>
<p>Make sure your solution builds without errors before running CI store - otherwise, the serialized data may not be in the correct format. </p>
</div>


<div>

</div>
<div>
<p>You can also inspect <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/blob/finished/scripts/Update-XperienceProjectWithDatabase.ps1" target="_blank">a similar sample PowerShell script</a> that updates both the Xperience project files and database.</p>
</div>

<h1 id="whats-next">What’s next?</h1>
<p>Scripts like these will save your developers time and uncertainty in recurring tasks. All they need to do to run one of these scripts is right-click and choose Run with PowerShell, or alternately, open a PowerShell command line in the <em>scripts</em> folder and call one of the files. You may want to customize these scripts to fit your team’s procedures or look into any other tasks that could potentially be automated in similar ways.</p>

</body>
</html>
