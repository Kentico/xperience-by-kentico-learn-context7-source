<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Access custom global configurations</title>
</head>
<body>
<p><a href="/guides/development/customizations-and-integrations/create-basic-module">Earlier in this series</a>, you learned how to create a custom module that holds custom channel-agnostic key-value-based settings.</p>
<p></p>
<p>Let’s say your customer wants to use the new module to define two custom email notification settings: <strong>Email notification recipients</strong> and <strong>Email notification sender</strong>.</p>

<p>Every time Xperience sends a certain type of email notification, these two settings should determine who the recipients and the sender are.</p>

<div>
<p><strong>How do you access the values in your code to meet the customer’s requirements?</strong></p>
<p>Using the <strong>email notification settings</strong> described above as an example, let’s explore how you can access custom module values and how to utilize the <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0" target="_blank">Options pattern</a> to work with custom settings defined in the Xperience in a strongly typed manner.</p>
</div>

<h2 id="before-you-start">Before you start</h2>
<p>This guide requires the following:</p>
<ul>
<li>Familiarity with <a href="https://learn.microsoft.com/en-us/dotnet/csharp/" target="_blank">C#</a>, <a href="https://learn.microsoft.com/en-us/dotnet/" target="_blank">.NET Core</a>, <a href="https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection" target="_blank">Dependency injection</a>, and the <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/overview" target="_blank">MVC pattern</a>.</li>
<li>A running instance of Xperience by Kentico, preferably <a href="/documentation/changelog">29.6.1</a> or higher.

<div>

</div>
<div>
Some features covered in the Training guides may not work in older versions.
</div>
</li>
</ul>
<p>The examples in this guide require that you:</p>
<ul>
<li>Have followed along with the samples from <a href="/guides/development/customizations-and-integrations/create-basic-module">the previous guide</a> that implement a custom module holding global settings.</li>
</ul>

<div>
<p><strong>Code samples</strong></p>
<p>You can find a project with completed, working versions of code samples from this guide and others in the <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/tree/finished" target="_blank">finished branch</a> of the <em>Training guides</em> repository.</p>
<p>The <a href="https://github.com/Kentico/xperience-by-kentico-training-guides" target="_blank">main branch</a> of the repository provides a starting point to code along with the guides.</p>
<p>The code samples in this guide are for <a href="https://learn.microsoft.com/en-us/dotnet/core/whats-new/dotnet-8/overview" target="_blank">.NET 8</a> only.</p>
<p>They come from a project that uses <a href="https://learn.microsoft.com/en-us/dotnet/core/project-sdk/overview#implicit-using-directives" target="_blank">implicit using directives</a>. You may need to add additional <code>using</code> directives to your code if your project does not use this feature.</p>
</div>

<h2 id="enter-the-data">Enter the data</h2>
<p>To follow along with the example here, use the UI developed earlier in this series to create two email notification settings, as seen in <a href="#EmailSettingsDemo">this video</a>.</p>
<p>You can copy-paste these values:</p>

<div>
<ul>
<li>
<strong>Display name:</strong> Email notification recipients</li>
<li>
<strong>Settings key code name:</strong> EmailNotificationToAddresses</li>
<li>
<strong>Value:</strong>:admin@localhost.local;support@localhost.local</li>
<li>
<strong>Notes:</strong> The email addresses that should receive custom email notifications. Separate addresses with a semi-colon.</li>
</ul>
<hr>
<ul>
<li>
<strong>Display name:</strong> Email notification sender</li>
<li>
<strong>Settings key code name:</strong> EmailNotificationFromAddress</li>
<li>
<strong>Value:</strong> notifications@localhost.local</li>
<li>
<strong>Notes:</strong> The email address that custom email notifications will be sent from.</li>
</ul>
</div>

<h2 id="expose-your-custom-configuration">Expose your custom configuration</h2>
<p>In general, you can access objects of custom classes in Xperience using the <a href="/documentation/developers-and-admins/api/objectquery-api">ObjectQuery API</a>.</p>
<p>Our module holds information related to system configuration (email notifications). To access it in a <strong>strongly typed manner</strong>, with the principles of <strong>encapsulation</strong> and <strong>separation of concerns</strong> in mind, we recommend using the <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0" target="_blank">Options pattern</a>.</p>

<div>

</div>
<div>
<p>If you are new to the Options pattern, outside of <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0" target="_blank">the official Microsoft documentation</a>, you may find <a href="https://www.milanjovanovic.tech/blog/how-to-use-the-options-pattern-in-asp-net-core-7" target="_blank">this article</a> or <a href="https://www.youtube.com/watch?v=wxYt0motww0" target="_blank">this video</a> helpful in understanding its basic principles.</p>
</div>

<p>In a nutshell, we will:</p>
<ol type="1">
<li>
<a href="#create-an-options-model">Create an options model</a> class to hold our configuration values.</li>
<li>
<a href="#map-configuration-to-the-options-model">Create an options “setup” class to populate the model</a> from Xperience objects using the ObjectQuery API.</li>
<li>
<a href="#register-the-options-setup-class">Register the option classes</a> with the DI container.</li>
<li>
<a href="#utilize-custom-settings-values-in-your-application">Use DI to access the values</a> and implement the desired functionality.</li>
</ol>
<h3 id="create-an-options-model">Create an options model</h3>
<p>In our example, the customer has defined two settings: <strong>Email notification recipients</strong> and <strong>Email notification sender</strong>.</p>
<p>Let’s create an <code>EmailNotificationOptions</code> class with two properties - one string value per setting.</p>

<div>

</div>
<div>
<p>Place your file in the <em>TrainingGuides.Web/Features/EmailNotifications</em> folder. If you are following along using <a href="https://github.com/Kentico/xperience-by-kentico-training-guides" target="_blank">our Training guides repository</a>, you can place all the files we’ll create in this folder.</p>
</div>


<div>
<div>
<div>
<span>C#</span>
</div>
<strong>EmailNotificationOptions.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
namespace TrainingGuides.Web.Features.EmailNotifications;
public class EmailNotificationOptions
{
    public string SenderAddress { get; set; } = string.Empty;

    public string RecipientAddresses { get; set; } = string.Empty;
}
</code></pre>
</div>

<h3 id="map-configuration-to-the-options-model">Map configuration to the options model</h3>
<p>Next, create an <code>EmailNotificationOptionsSetup</code> class that implements the <code>IConfigureOptions&lt;TOptions&gt;</code> interface, and pass in the <code>EmailNotificationOptions</code> model class.</p>
<p>Both email notification settings are objects of the <code>GlobalSettingsKeyInfo</code> class from <a href="/guides/development/customizations-and-integrations/create-basic-module#create-data-class">earlier in this series</a>.</p>
<p>Retrieve global settings with the generic <code>IInfoProvider</code>, using <a href="/documentation/developers-and-admins/api/objectquery-api">ObjectQuery API extension methods</a> to filter your query based on their <strong>Settings key code name</strong>.</p>
<p></p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>EmailNotificationOptionsSetup.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
using CMS.DataEngine;
using Microsoft.Extensions.Options;
using TrainingGuides.ProjectSettings;

namespace TrainingGuides.Web.Features.EmailNotifications;

public class EmailNotificationOptionsSetup : IConfigureOptions&lt;EmailNotificationOptions&gt;
{
    // Settings key code names of the two email notification settings.
    private const string FROM_ADDRESS_SETTINGS_KEY = "EmailNotificationFromAddress";
    private const string TO_ADDRESSES_SETTINGS_KEY = "EmailNotificationToAddresses";

    // Provide access to the objects of GlobalSettingsKeyInfo class using the generic IInfo provider and dependency injection.
    private readonly IInfoProvider&lt;GlobalSettingsKeyInfo&gt; globalSettingsKeyInfoProvider;

    public EmailNotificationOptionsSetup(IInfoProvider&lt;GlobalSettingsKeyInfo&gt; globalSettingsKeyInfoProvider)
    {
        this.globalSettingsKeyInfoProvider = globalSettingsKeyInfoProvider;
    }

    // Implement the Configure method of the IConfigureOptions interface.
    public void Configure(EmailNotificationOptions options)
    {
        // Retrieve GlobalSettingsKeyInfo objects
        // with a 'EmailNotificationFromAddress' or 'EmailNotificationToAddresses' code name
        // using ObjectQuery API.
        var emailSettings = globalSettingsKeyInfoProvider.Get()
            .WhereEquals(nameof(GlobalSettingsKeyInfo.GlobalSettingsKeyName), FROM_ADDRESS_SETTINGS_KEY)
            .Or()
            .WhereEquals(nameof(GlobalSettingsKeyInfo.GlobalSettingsKeyName), TO_ADDRESSES_SETTINGS_KEY)
            .GetEnumerableTypedResult();

        // Filter out sender address and recipient addresses and store them in variables respectively.
        var fromAddress = emailSettings.FirstOrDefault(s =&gt; s.GlobalSettingsKeyName == FROM_ADDRESS_SETTINGS_KEY);
        var toAddresses = emailSettings.FirstOrDefault(s =&gt; s.GlobalSettingsKeyName == TO_ADDRESSES_SETTINGS_KEY);

        // Populate the EmailNotificationOptions model.
        options.SenderAddress = fromAddress?.GlobalSettingsKeyValue ?? string.Empty;
        options.RecipientAddresses = toAddresses?.GlobalSettingsKeyValue ?? string.Empty;
    }
}
</code></pre>
</div>

<h3 id="register-the-options-setup-class">Register the options setup class</h3>
<p>Now, you need to tell your application to use your new custom class. Register the setup class and associated model with the DI container by calling <code>builder.Services.ConfigureOptions&lt;EmailNotificationOptionsSetup&gt;();</code> before application build.</p>
<p>Our <a href="https://github.com/Kentico/xperience-by-kentico-training-guides/blob/finished/src/TrainingGuides.Web/ServiceCollectionExtensions.cs" target="_blank">Training guides repository</a> uses a static <code>ServiceCollectionExtensions</code> class to register all services.</p>
<p>If you are working in this repo or you extract service registrations in your project in a similar way, there are two steps:</p>
<ol type="1">
<li>
<p>Add a new static method to register options (<code>AddTrainingGuidesOptions</code> method below).</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ServiceCollectionExtensions.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
 ...
 using TrainingGuides.Web.Features.EmailNotifications;

 namespace TrainingGuides.Web;

 public static class ServiceCollectionExtensions
 {
     public static void AddTrainingGuidesServices(this IServiceCollection services)
     {
         ...
     }

     // New static method to register options.
     public static void AddTrainingGuidesOptions(this IServiceCollection services)
     {
         // Register your custom options setup class with the DI container.
         services.ConfigureOptions&lt;EmailNotificationOptionsSetup&gt;();
     }
 }
 </code></pre>
</div>
</li>
<li>
<p>Call the new method in <em>Program.cs</em> on application start.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>Program.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
...

builder.Services.AddTrainingGuidesServices();
// new method call
builder.Services.AddTrainingGuidesOptions();
...

var app = builder.Build();

app.InitKentico();
...
</code></pre>
</div>
</li>
</ol>
<h2 id="utilize-custom-settings-values-in-your-application">Utilize custom settings values in your application</h2>
<p>Thanks to the options pattern, you can now easily access your configuration anywhere in your code where dependency injection is available.</p>
<p>Choose any of the <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0#options-interfaces" target="_blank">options interfaces</a> that best fits your use case and application lifecycle.</p>

<div>

</div>
<div>
<p>For example, <code>IOptions&lt;TOptions&gt;</code> is a singleton service that holds a snapshot of the settings at the time of its first construction. It will work well in cases where the configuration values do not change during the application’s life.</p>
<p>In other scenarios, it may be better to take advantage of a scoped service, <code>IOptionsSnapshot&lt;TOptions&gt;</code>, which re-evaluates the options every time it’s constructed.</p>
<p><code>IOptionsMonitor&lt;TOptions&gt;</code>, as the name suggests, is a suitable choice if you need a singleton service to monitor values that you expect to change continuously.</p>
<p>Find the full list of options interfaces in the <a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/configuration/options?view=aspnetcore-8.0#options-interfaces" target="_blank">official Microsoft documentation</a>.</p>
</div>

<h3 id="build-a-notification-service">Build a notification service</h3>
<p>Let’s build a service that will send notifications to your configured email addresses.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>IEmailNotificationService.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
namespace TrainingGuides.Web.Features.EmailNotifications;
public interface IEmailNotificationService
{
    Task SendEmailAsync(string subject, string message);
}
</code></pre>
</div>


<div>
<div>
<div>
<span>C#</span>
</div>
<strong>EmailNotificationService.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
using CMS.EmailEngine;
using Microsoft.Extensions.Options;

namespace TrainingGuides.Web.Features.EmailNotifications;

public class EmailNotificationService : IEmailNotificationService
{
    private readonly IEmailService emailService;

    // Use DI to access your configuration options
    private readonly IOptionsMonitor&lt;EmailNotificationOptions&gt; emailNotificationOptions;
    private readonly IOptionsMonitorCache&lt;EmailNotificationOptions&gt; emailNotificationOptionsCache;

    public EmailNotificationService(IEmailService emailService,
        IOptionsMonitor&lt;EmailNotificationOptions&gt; emailNotificationOptions,
        IOptionsMonitorCache&lt;EmailNotificationOptions&gt; emailNotificationOptionsCache)
    {
        this.emailService = emailService;
        this.emailNotificationOptions = emailNotificationOptions;
        this.emailNotificationOptionsCache = emailNotificationOptionsCache;
    }

    public async Task SendEmailAsync(string subject, string message)
    {
        // Clear the options cache to ensure we always get the latest data when settings have changed.
        emailNotificationOptionsCache.Clear();

        var msg = new EmailMessage()
        {
            // Assign the email sender based on the configuration.
            From = emailNotificationOptions.CurrentValue.SenderAddress,

            // Assign email recipients based on the configuration.
            Recipients = emailNotificationOptions.CurrentValue.RecipientAddresses,

            Priority = EmailPriorityEnum.Normal,

            Subject = subject,

            Body = message,
        };
        await emailService.SendEmail(msg);
    }
}
</code></pre>
</div>

<p>Register your service.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>ServiceCollectionExtensions.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
...
using TrainingGuides.Web.Features.EmailNotifications;

namespace TrainingGuides.Web;

public static class ServiceCollectionExtensions
{
    public static void AddTrainingGuidesServices(this IServiceCollection services)
    {
        services.AddSingleton&lt;IHttpRequestService, HttpRequestService&gt;();
        ...
        // Register EmailNotificationService as a singleton service.
        services.AddSingleton&lt;IEmailNotificationService, EmailNotificationService&gt;();
    }
    ...
}

</code></pre>
</div>


<div>

</div>
<div>
<p>Notice that we use <code>IOptionsMonitor&lt;TOptions&gt;</code> to inject notification options. This way, we can monitor the settings while saving resources using a singleton service.</p>
<p>The options are cached. For simplicity, we clear the cache each time the <code>SendEmailAsync</code> method fires so that we always have fresh data. A more advanced approach example could be implementing another global handler that watches the settings keys.</p>
<p>Because the <code>IOptionsMonitor&lt;TOptions&gt;</code> is a singleton, we registered our <code>EmailNotificationService</code> in the same way.</p>
</div>

<h3 id="watch-your-settings-work-in-practice">Watch your settings work in practice</h3>
<p>To see our email notifications based on custom global settings at work, let’s generate a notification every time a new user is created in the system.</p>
<p>We will achieve this by creating a <a href="/documentation/developers-and-admins/customization/handle-global-events/handle-object-events">custom object handler (module class)</a> and assign it to the <code>UserInfo</code> class.</p>

<div>
<div>
<div>
<span>C#</span>
</div>
<strong>EmailNotificationHandlerModule.cs</strong>
</div>
<div>
<button>
<span></span><span></span> <span>Copy</span>
</button>
</div>
</div>
<div>
<pre><code>
using CMS;
using CMS.Core;
using CMS.DataEngine;
using CMS.Membership;
using TrainingGuides.Web.Features.EmailNotifications;

[assembly: RegisterModule(typeof(EmailNotificationHandlerModule))]

namespace TrainingGuides.Web.Features.EmailNotifications;
public class EmailNotificationHandlerModule : Module
{

    private IEmailNotificationService? emailNotificationService;

    public EmailNotificationHandlerModule() : base("EmailNotificationHandler")
    { }
    
    // Initialization code that is executed when the application starts.
    protected override void OnInit(ModuleInitParameters parameters)
    {
        base.OnInit();

        emailNotificationService = parameters.Services.GetRequiredService&lt;IEmailNotificationService&gt;();

        // Assign a handler to the Insert.After event for the UserInfo class.
        // This event occurs after a new user object is created.
        UserInfo.TYPEINFO.Events.Insert.After += User_InsertAfter;
    }

    private void User_InsertAfter(object? sender, ObjectEventArgs e)
    {
        if (e.Object is not UserInfo user)
        {
            return;
        }

        // Send the email using our Email notification service.
        emailNotificationService?.SendEmailAsync($"New user created ({user.Email})", $"New user inserted with ID {user.UserID}, email {user.Email}, guid {user.UserGUID}");
    }
}
</code></pre>
</div>


<div>

</div>
<div>
<p>You may have noticed we are using the <code>parameters.Services.GetRequiredService</code> method rather than dependency injection to access the <code>EmailNotificationService</code>.</p>
<p>We recommend this practice in module classes due to the nature of the Xperience application lifecycle. The initialization order of modules during application startup is not guaranteed, and it is possible that when your module initializes, DI will not be available yet.</p>
<p>See more <a href="/documentation/developers-and-admins/customization/run-code-on-application-startup">information and examples in our documentation</a>.</p>
</div>

<p>Build and run your solution. Navigate to the Xperience administration and add a new user. If you entered valid email addresses in the <strong>Project settings</strong>, the recipients should receive an email notification.</p>
<p>Alternatively, you can place a breakpoint in your application to see that your custom global settings are propagating in your application on user creation.</p>


<div>

</div>
<div>
<p>Try changing the email addresses and creating another user. If you followed our example and used the <code>IOptionsMonitor&lt;TOptions&gt;</code> options interface, you should see the changes take effect without restarting your app.</p>
</div>

<h2 id="whats-next">What’s next</h2>
<p>In this and the <a href="/guides/development/customizations-and-integrations/create-basic-module">previous guide</a>, we talked about utilizing modules in Xperience by Kentico to implement custom global (channel-agnostic) settings.</p>
<p>Continue with this series’s <a href="/guides/development/customizations-and-integrations/add-channels-to-module">next two guides</a> to learn how to implement custom settings applicable per website channel.</p>

</body>
</html>
